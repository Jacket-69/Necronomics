---
phase: 03-transactions-and-balances
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/db/models.rs
  - src-tauri/src/db/queries/transactions.rs
  - src-tauri/src/db/queries/mod.rs
  - src-tauri/src/commands/transactions.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/types/index.ts
  - src/lib/tauri.ts
  - src/lib/formatters.ts
  - src/lib/hooks.ts
autonomous: true
requirements:
  - TXN-01
  - TXN-02
  - TXN-03
  - TXN-05
  - TXN-06
  - TXN-07
  - TXN-08
  - BAL-01
  - BAL-02

must_haves:
  truths:
    - "Backend can create a transaction and update account balance atomically in one SQL transaction"
    - "Backend can list transactions with dynamic filters (account, category, type, date range, amount range, search) plus sorting and pagination"
    - "Backend can return per-account balances with a consolidated total in base currency"
    - "TypeScript types match Rust serde(rename_all=camelCase) serialization shape exactly"
    - "Amount conversion utilities correctly handle all 5 currencies (CLP/JPY 0 decimals, USD/EUR/CNY 2 decimals)"
  artifacts:
    - path: "src-tauri/src/db/models.rs"
      provides: "Transaction, TransactionFilter, PaginatedResult, AccountBalance, BalanceSummary structs"
      contains: "pub struct Transaction"
    - path: "src-tauri/src/db/queries/transactions.rs"
      provides: "CRUD queries + dynamic filtered list + count using QueryBuilder"
      exports: ["create", "get_by_id", "update", "delete", "list_filtered", "count_filtered"]
    - path: "src-tauri/src/commands/transactions.rs"
      provides: "Tauri IPC commands with atomic balance updates"
      exports:
        [
          "create_transaction",
          "update_transaction",
          "delete_transaction",
          "list_transactions",
          "get_balance_summary",
        ]
    - path: "src/types/index.ts"
      provides: "Transaction, TransactionFilters, PaginatedResult, BalanceSummary TS types"
      contains: "export interface Transaction"
    - path: "src/lib/tauri.ts"
      provides: "transactionApi invoke wrappers"
      contains: "export const transactionApi"
    - path: "src/lib/formatters.ts"
      provides: "toMinorUnits, fromMinorUnits conversion functions"
      contains: "export const toMinorUnits"
    - path: "src/lib/hooks.ts"
      provides: "useDebounce custom hook"
      contains: "export const useDebounce"
  key_links:
    - from: "src-tauri/src/commands/transactions.rs"
      to: "src-tauri/src/db/queries/transactions.rs"
      via: "function calls for CRUD operations"
      pattern: "queries::transactions::"
    - from: "src-tauri/src/commands/transactions.rs"
      to: "sqlx pool.begin()/commit()"
      via: "atomic SQL transaction for balance updates"
      pattern: "pool\\.begin\\(\\)"
    - from: "src/lib/tauri.ts"
      to: "Tauri IPC commands"
      via: "invoke() calls with typed wrappers"
      pattern: "invoke\\(\"(create|update|delete|list)_transaction"
---

<objective>
Build the complete data layer for transactions: Rust backend (models, queries with dynamic filtering, commands with atomic balance updates) and TypeScript contracts (types, API wrappers, utility functions).

Purpose: Establish the backend and typed frontend contracts so that subsequent plans can build the UI (store, forms, table) against a working data layer.
Output: 5 Tauri commands (create, update, delete, list, balance summary), TypeScript types matching Rust shapes, typed invoke wrappers, amount conversion utilities, debounce hook.
</objective>

<execution_context>
@/home/jacket/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/jacket/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-transactions-and-balances/03-RESEARCH.md

<interfaces>
<!-- Existing Rust patterns the executor must follow exactly -->

From src-tauri/src/db/models.rs (existing model pattern):

```rust
#[derive(Debug, FromRow, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Account {
    pub id: String,
    pub name: String,
    #[sqlx(rename = "type")]
    #[serde(rename = "type")]
    pub account_type: String,
    pub currency_id: String,
    pub balance: i64,
    pub credit_limit: Option<i64>,
    pub billing_day: Option<i32>,
    pub is_active: i32,
    pub created_at: String,
}
```

From src-tauri/src/db/queries/categories.rs (existing query pattern):

```rust
pub async fn get_all(pool: &SqlitePool) -> Result<Vec<Category>, sqlx::Error> {
    sqlx::query_as::<_, Category>("SELECT ... FROM categories WHERE is_active = 1 ...")
        .fetch_all(pool).await
}
pub async fn create(pool: &SqlitePool, id: &str, ...) -> Result<Category, sqlx::Error> {
    sqlx::query("INSERT INTO categories (...) VALUES (?, ?, ?, ?, ?)")
        .bind(id).bind(name)...
        .execute(pool).await?;
    get_by_id(pool, id).await?.ok_or_else(|| sqlx::Error::RowNotFound)
}
```

From src-tauri/src/commands/categories.rs (existing command pattern):

```rust
#[tauri::command]
pub async fn create_category(
    pool: State<'_, SqlitePool>,
    name: String, category_type: String, icon: Option<String>, parent_id: Option<String>,
) -> Result<Category, String> {
    // business validation...
    let id = uuid::Uuid::new_v4().to_string();
    categories::create(&pool, &id, &name, &final_type, ...)
        .await.map_err(|e| e.to_string())
}
```

From src-tauri/src/lib.rs (command registration):

```rust
.invoke_handler(tauri::generate_handler![
    commands::accounts::list_accounts,
    // ... add new transaction commands here
])
```

From src/types/index.ts (existing TS type pattern):

```typescript
export type CategoryType = "income" | "expense";
export interface Category {
  id: string;
  name: string;
  type: CategoryType;
  icon: string | null;
  parentId: string | null;
  isActive: number;
  createdAt: string;
}
```

From src/lib/tauri.ts (existing invoke wrapper pattern):

```typescript
export const categoryApi = {
  list: (): Promise<Category[]> => invoke("list_categories"),
  get: (id: string): Promise<Category> => invoke("get_category", { id }),
  create: (input: CreateCategoryInput): Promise<Category> => invoke("create_category", { ... }),
  // ...
};
```

From DB schema (001_initial_schema.sql — transactions table):

```sql
CREATE TABLE transactions (
    id TEXT PRIMARY KEY,
    account_id TEXT NOT NULL REFERENCES accounts(id),
    category_id TEXT NOT NULL REFERENCES categories(id),
    amount INTEGER NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('income', 'expense')),
    description TEXT NOT NULL,
    date TEXT NOT NULL,
    notes TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);
CREATE INDEX idx_transactions_date ON transactions(date);
CREATE INDEX idx_transactions_category ON transactions(category_id);
CREATE INDEX idx_transactions_account ON transactions(account_id);
CREATE INDEX idx_transactions_type ON transactions(type);
CREATE INDEX idx_transactions_description ON transactions(description);
```

From DB schema (exchange_rates table):

```sql
CREATE TABLE exchange_rates (
    id TEXT PRIMARY KEY,
    from_currency_id TEXT NOT NULL REFERENCES currencies(id),
    to_currency_id TEXT NOT NULL REFERENCES currencies(id),
    rate REAL NOT NULL,
    date TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(from_currency_id, to_currency_id, date)
);
```

From src/lib/formatters.ts (existing currency config):

```typescript
const CURRENCY_CONFIG: Record<string, { symbol: string; decimals: number }> = {
  CLP: { symbol: "$", decimals: 0 },
  USD: { symbol: "US$", decimals: 2 },
  EUR: { symbol: "\u20AC", decimals: 2 },
  JPY: { symbol: "\u00A5", decimals: 0 },
  CNY: { symbol: "\u00A5", decimals: 2 },
};
```

</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rust models and transaction queries with QueryBuilder</name>
  <files>
    src-tauri/src/db/models.rs
    src-tauri/src/db/queries/transactions.rs
    src-tauri/src/db/queries/mod.rs
  </files>
  <action>
    **In models.rs**, add these structs after the existing Currency struct:

    1. `Transaction` struct with `#[derive(Debug, FromRow, Serialize, Deserialize, Clone)]` and `#[serde(rename_all = "camelCase")]`. Fields: `id: String`, `account_id: String`, `category_id: String`, `amount: i64`, `transaction_type: String` (with `#[sqlx(rename = "type")]` and `#[serde(rename = "type")]` — same pattern as Account/Category), `description: String`, `date: String`, `notes: Option<String>`, `created_at: String`.

    2. `TransactionFilter` struct with `#[derive(Debug, Deserialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `account_id: Option<String>`, `category_id: Option<String>`, `transaction_type: Option<String>`, `date_from: Option<String>`, `date_to: Option<String>`, `amount_min: Option<i64>`, `amount_max: Option<i64>`, `search: Option<String>`, `sort_by: Option<String>`, `sort_dir: Option<String>`, `page: Option<i64>`, `page_size: Option<i64>`.

    3. `PaginatedResult<T>` generic struct with `#[derive(Debug, Serialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `data: Vec<T>`, `total: i64`, `page: i64`, `page_size: i64`, `total_pages: i64`. Use `where T: Serialize`.

    4. `AccountBalance` struct with `#[derive(Debug, Serialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `account_id: String`, `account_name: String`, `balance: i64`, `currency_code: String`.

    5. `BalanceSummary` struct with `#[derive(Debug, Serialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `accounts: Vec<AccountBalance>`, `consolidated_total: Option<i64>`, `base_currency_code: String`.

    **In queries/transactions.rs**, create the queries module:

    1. `get_by_id(pool, id) -> Result<Option<Transaction>>` — standard query_as pattern.

    2. `create(pool, id, account_id, category_id, amount, transaction_type, description, date) -> Result<Transaction>` — INSERT then get_by_id.

    3. `update(pool, id, account_id, category_id, amount, transaction_type, description, date) -> Result<Transaction>` — UPDATE all fields, then get_by_id.

    4. `delete(pool, id) -> Result<()>` — DELETE by id.

    5. `count_filtered(pool, filter: &TransactionFilter) -> Result<i64>` — Uses `QueryBuilder<Sqlite>`. Start with `SELECT COUNT(*) FROM transactions WHERE 1=1`. Add WHERE clauses conditionally via `push(" AND col = ").push_bind(val)` for each filter field. For `search`, use `push(" AND description LIKE ").push_bind(format!("%{s}%"))`. Build with `build_query_as::<(i64,)>()` and `fetch_one`.

    6. `list_filtered(pool, filter: &TransactionFilter) -> Result<Vec<Transaction>>` — Uses `QueryBuilder<Sqlite>`. Same WHERE conditions as count_filtered. Add ORDER BY with whitelist validation: valid columns are `["date", "amount", "description", "type", "created_at"]` — default to `"date"`, default dir to `"DESC"`. Push ORDER BY as format string (safe because whitelisted). Add LIMIT/OFFSET with `push(" LIMIT ").push_bind(page_size)` and `push(" OFFSET ").push_bind(offset)`. Default page=1, page_size=20. `offset = (page - 1) * page_size`. Build with `build_query_as::<Transaction>()` and `fetch_all`.

    CRITICAL: `QueryBuilder` does NOT implement Clone. The count and list functions MUST be separate functions that each build their own QueryBuilder. A helper function `apply_filters(builder: &mut QueryBuilder<Sqlite>, filter: &TransactionFilter)` can DRY the WHERE clause building.

    7. `get_account_id_for_transaction(pool, transaction_id) -> Result<String>` — helper to get the account_id of a transaction before delete/update (needed for balance recalculation).

    **In queries/mod.rs**, add `pub mod transactions;`.

  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>All 5 model structs compile. All 7 query functions compile. QueryBuilder used for dynamic filtering with push_bind (no string interpolation for values). queries/mod.rs exports transactions module.</done>
</task>

<task type="auto">
  <name>Task 2: Rust transaction commands with atomic balance updates</name>
  <files>
    src-tauri/src/commands/transactions.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    **In commands/transactions.rs**, create 5 Tauri commands following the established pattern (async fn with `State<'_, SqlitePool>`, returning `Result<T, String>`):

    1. `create_transaction(pool, account_id, category_id, amount: i64, transaction_type, description, date) -> Result<Transaction, String>`:
       - Validate: account_id exists and is active, category_id exists and is active, type matches category type (income category for income transaction), amount > 0, date is non-empty.
       - Generate UUID id.
       - Use `pool.begin()` to start a SQL transaction.
       - Insert via raw sqlx query within the transaction (pass `&mut *db_txn` as executor, NOT the pool).
       - Recalculate account balance with: `UPDATE accounts SET balance = (SELECT COALESCE(SUM(CASE WHEN type = 'income' THEN amount ELSE -amount END), 0) FROM transactions WHERE account_id = ?) WHERE id = ?` — execute within the same SQL transaction.
       - `db_txn.commit().await`.
       - Return the created transaction via `queries::transactions::get_by_id`.
       - Description: if empty string is received, store it as empty string (NOT NULL column, empty string = no description per convention).

    2. `update_transaction(pool, id, account_id, category_id, amount: Option<i64>, transaction_type: Option<String>, description: Option<String>, date: Option<String>) -> Result<Transaction, String>`:
       - Fetch existing transaction (error if not found).
       - Determine old_account_id from existing.
       - Determine new_account_id (if account_id changed).
       - Use `pool.begin()`.
       - UPDATE the transaction fields (merge existing with provided optionals, similar to category update pattern).
       - Recalculate balance for old_account_id.
       - If account_id changed, also recalculate balance for new_account_id.
       - `db_txn.commit().await`.
       - Return updated transaction.

    3. `delete_transaction(pool, id) -> Result<(), String>`:
       - Fetch existing transaction to get account_id.
       - Use `pool.begin()`.
       - DELETE the transaction.
       - Recalculate account balance (same SUM query).
       - `db_txn.commit().await`.

    4. `list_transactions(pool, filter: TransactionFilter) -> Result<PaginatedResult<Transaction>, String>`:
       - Call `count_filtered(pool, &filter)` and `list_filtered(pool, &filter)`.
       - Compute `total_pages = (total + page_size - 1) / page_size` (ceiling division).
       - Return `PaginatedResult { data, total, page, page_size, total_pages }`.

    5. `get_balance_summary(pool, base_currency_id: Option<String>) -> Result<BalanceSummary, String>`:
       - Fetch all active accounts with balance > 0 or any balance (all active accounts).
       - For each account, create `AccountBalance { account_id, account_name, balance, currency_code }`. Extract currency_code from currency_id using the same pattern as frontend: strip "cur_" prefix and uppercase. OR join with currencies table to get the code.
       - Determine base_currency_id: use provided or default to "cur_clp".
       - For consolidated total: for each account, if currency matches base currency, add balance directly. If different currency, query exchange_rates for latest rate (ORDER BY date DESC LIMIT 1) where from_currency = account.currency and to_currency = base_currency. If rate found, convert: `(balance as f64 * rate).round() as i64`. If no rate found, skip that account in consolidation.
       - `consolidated_total` is `Some(sum)` if at least one account included, `None` if no accounts exist.
       - Return `BalanceSummary { accounts, consolidated_total, base_currency_code }`.

    **IMPORTANT for balance recalculation:** Extract a helper function `recalculate_account_balance(db_txn: &mut sqlx::Transaction<'_, Sqlite>, account_id: &str)` that runs the SUM-based UPDATE. This avoids code duplication across create/update/delete.

    **In commands/mod.rs**, add `pub mod transactions;`.

    **In lib.rs**, add all 5 commands to `tauri::generate_handler![]`:
    ```
    commands::transactions::create_transaction,
    commands::transactions::update_transaction,
    commands::transactions::delete_transaction,
    commands::transactions::list_transactions,
    commands::transactions::get_balance_summary,
    ```

  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>All 5 commands compile and are registered in lib.rs. create/update/delete use pool.begin()/commit() for atomic balance updates. list_transactions returns PaginatedResult. get_balance_summary handles missing exchange rates gracefully.</done>
</task>

<task type="auto">
  <name>Task 3: TypeScript types, invoke wrappers, and utility functions</name>
  <files>
    src/types/index.ts
    src/lib/tauri.ts
    src/lib/formatters.ts
    src/lib/hooks.ts
  </files>
  <action>
    **In types/index.ts**, add after the existing UpdateCategoryInput:

    ```typescript
    export type TransactionType = "income" | "expense";

    export interface Transaction {
      id: string;
      accountId: string;
      categoryId: string;
      amount: number; // integer minor units
      type: TransactionType;
      description: string;
      date: string;
      notes: string | null;
      createdAt: string;
    }

    export interface CreateTransactionInput {
      accountId: string;
      categoryId: string;
      amount: number; // already in minor units
      transactionType: TransactionType;
      description: string;
      date: string;
    }

    export interface UpdateTransactionInput {
      accountId?: string;
      categoryId?: string;
      amount?: number;
      transactionType?: TransactionType;
      description?: string;
      date?: string;
    }

    export interface TransactionFilters {
      accountId?: string | null;
      categoryId?: string | null;
      transactionType?: string | null;
      dateFrom?: string | null;
      dateTo?: string | null;
      amountMin?: number | null;
      amountMax?: number | null;
      search?: string | null;
      sortBy?: string | null;
      sortDir?: "ASC" | "DESC" | null;
      page?: number | null;
      pageSize?: number | null;
    }

    export interface PaginatedResult<T> {
      data: T[];
      total: number;
      page: number;
      pageSize: number;
      totalPages: number;
    }

    export interface AccountBalance {
      accountId: string;
      accountName: string;
      balance: number;
      currencyCode: string;
    }

    export interface BalanceSummary {
      accounts: AccountBalance[];
      consolidatedTotal: number | null;
      baseCurrencyCode: string;
    }
    ```

    **In lib/tauri.ts**, add import for new types and create `transactionApi`:

    ```typescript
    export const transactionApi = {
      list: (filters: TransactionFilters): Promise<PaginatedResult<Transaction>> =>
        invoke("list_transactions", { filter: filters }),

      create: (input: CreateTransactionInput): Promise<Transaction> =>
        invoke("create_transaction", {
          accountId: input.accountId,
          categoryId: input.categoryId,
          amount: input.amount,
          transactionType: input.transactionType,
          description: input.description,
          date: input.date,
        }),

      update: (id: string, input: UpdateTransactionInput): Promise<Transaction> =>
        invoke("update_transaction", { id, ...input }),

      delete: (id: string): Promise<void> =>
        invoke("delete_transaction", { id }),

      getBalanceSummary: (baseCurrencyId?: string): Promise<BalanceSummary> =>
        invoke("get_balance_summary", { baseCurrencyId: baseCurrencyId ?? null }),
    };
    ```

    **In lib/formatters.ts**, add after existing exports:

    ```typescript
    export const toMinorUnits = (amount: number, decimalPlaces: number): number => {
      return Math.round(amount * Math.pow(10, decimalPlaces));
    };

    export const fromMinorUnits = (minorUnits: number, decimalPlaces: number): number => {
      return decimalPlaces === 0 ? minorUnits : minorUnits / Math.pow(10, decimalPlaces);
    };
    ```

    **Create lib/hooks.ts** (new file):

    ```typescript
    import { useEffect, useState } from "react";

    export const useDebounce = <T>(value: T, delay: number = 300): T => {
      const [debounced, setDebounced] = useState(value);
      useEffect(() => {
        const timer = setTimeout(() => setDebounced(value), delay);
        return () => clearTimeout(timer);
      }, [value, delay]);
      return debounced;
    };
    ```

  </action>
  <verify>
    <automated>cd src && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>All TypeScript types compile. transactionApi has 5 methods matching the 5 Tauri commands. toMinorUnits/fromMinorUnits exported from formatters.ts. useDebounce hook exported from hooks.ts. All type shapes match Rust serde(rename_all=camelCase) output.</done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` — Rust compiles with all models, queries, and commands
2. `npx tsc --noEmit` — TypeScript compiles with all new types and API wrappers
3. Manual verification: grep for `pool.begin()` in commands/transactions.rs to confirm atomic balance updates
4. Manual verification: grep for `push_bind` in queries/transactions.rs to confirm parameterized dynamic queries (no SQL injection)
</verification>

<success_criteria>

- Rust backend compiles with 5 registered Tauri commands for transaction CRUD + balance summary
- Transaction create/update/delete atomically update account balance via SQL transaction
- Dynamic list query uses QueryBuilder with push_bind for all filter parameters
- Balance summary gracefully handles missing exchange rates (returns None for consolidated when no rates)
- TypeScript types, invoke wrappers, formatters, and debounce hook all compile
- Sort column whitelist prevents SQL injection in ORDER BY clause
  </success_criteria>

<output>
After completion, create `.planning/phases/03-transactions-and-balances/03-01-SUMMARY.md`
</output>
