---
phase: 04-debts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/db/migrations/005_create_installments.sql
  - src-tauri/src/db/models.rs
  - src-tauri/src/db/queries/debts.rs
  - src-tauri/src/db/queries/mod.rs
  - src-tauri/src/commands/debts.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/types/index.ts
  - src/lib/tauri.ts
autonomous: true
requirements:
  - DEBT-01
  - DEBT-02
  - DEBT-03
  - DEBT-04
  - DEBT-05
  - DEBT-06
  - DEBT-07

must_haves:
  truths:
    - "Backend can create a debt and auto-generate all installment rows with correct due dates derived from billing_day or start_date"
    - "Backend can list debts with computed paid_installments count from the installments table"
    - "Backend can list installments for a given debt with status and dates"
    - "Backend can mark an installment as paid, atomically creating an expense transaction and recalculating account balance"
    - "Backend can return credit utilization (balance, remaining commitments, credit_limit) for credit-card accounts"
    - "Backend can return 6-month payment projections grouped by month and debt"
    - "TypeScript types for Debt, Installment, CreditUtilization, MonthlyProjection match Rust serde shapes exactly"
  artifacts:
    - path: "src-tauri/src/db/migrations/005_create_installments.sql"
      provides: "installments table with debt_id FK, status check constraint, unique installment_number per debt"
      contains: "CREATE TABLE installments"
    - path: "src-tauri/src/db/models.rs"
      provides: "Debt, Installment, DebtFilter, DebtWithInstallments, CreditUtilization, MonthlyProjection structs"
      contains: "pub struct Debt"
    - path: "src-tauri/src/db/queries/debts.rs"
      provides: "CRUD queries for debts and installments"
      exports: ["get_debt_by_id", "list_debts", "create_debt", "update_debt", "list_installments_for_debt", "get_installment_by_id"]
    - path: "src-tauri/src/commands/debts.rs"
      provides: "Tauri IPC commands for debt lifecycle, mark-as-paid, credit utilization, projections"
      exports: ["create_debt", "update_debt", "delete_debt", "list_debts", "get_debt_detail", "mark_installment_paid", "get_credit_utilization", "get_payment_projections"]
    - path: "src/types/index.ts"
      provides: "Debt, Installment, CreditUtilization, MonthlyProjection, DebtProjectionRow TS types"
      contains: "export interface Debt"
    - path: "src/lib/tauri.ts"
      provides: "debtApi invoke wrappers"
      contains: "export const debtApi"
  key_links:
    - from: "src-tauri/src/commands/debts.rs"
      to: "src-tauri/src/db/queries/debts.rs"
      via: "function calls for debt/installment CRUD"
      pattern: "queries::debts::"
    - from: "src-tauri/src/commands/debts.rs"
      to: "sqlx pool.begin()/commit()"
      via: "atomic SQL transaction for mark-as-paid (installment update + transaction insert + balance recalculation)"
      pattern: "pool\\.begin\\(\\)"
    - from: "src/lib/tauri.ts"
      to: "Tauri IPC commands"
      via: "invoke() calls with typed wrappers"
      pattern: "invoke\\(\"(create|update|delete|list)_debt"
    - from: "src-tauri/src/db/migrations/005_create_installments.sql"
      to: "debts table"
      via: "foreign key debt_id REFERENCES debts(id) ON DELETE CASCADE"
      pattern: "REFERENCES debts\\(id\\)"
---

<objective>
Build the complete data layer for debts: SQLite migration for installments table, Rust backend (models, queries, commands with atomic mark-as-paid), and TypeScript contracts (types, API wrappers).

Purpose: Establish the backend and typed frontend contracts so that subsequent plans can build the Debts page UI against a working data layer.
Output: 8 Tauri commands (debt CRUD, detail, mark-as-paid, credit utilization, projections), installments migration, TypeScript types matching Rust shapes, typed invoke wrappers.
</objective>

<execution_context>
@/home/jacket/.claude/get-shit-done/workflows/execute-plan.md
@/home/jacket/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-debts/04-RESEARCH.md
@.planning/phases/04-debts/04-CONTEXT.md

<interfaces>
<!-- Existing Rust patterns the executor must follow exactly -->

From src-tauri/src/db/models.rs (existing model pattern):

```rust
#[derive(Debug, FromRow, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Account {
    pub id: String,
    pub name: String,
    #[sqlx(rename = "type")]
    #[serde(rename = "type")]
    pub account_type: String,
    pub currency_id: String,
    pub balance: i64,
    pub credit_limit: Option<i64>,
    pub billing_day: Option<i32>,
    pub is_active: i32,
    pub created_at: String,
}

pub struct Transaction {
    pub id: String,
    pub account_id: String,
    pub category_id: String,
    pub amount: i64,
    #[sqlx(rename = "type")]
    #[serde(rename = "type")]
    pub transaction_type: String,
    pub description: String,
    pub date: String,
    pub notes: Option<String>,
    pub created_at: String,
}
```

From src-tauri/src/commands/transactions.rs (atomic balance pattern):

```rust
async fn recalculate_account_balance(
    db_txn: &mut sqlx::Transaction<'_, Sqlite>,
    account_id: &str,
) -> Result<(), String> {
    sqlx::query(
        "UPDATE accounts SET balance = (
            SELECT COALESCE(SUM(CASE WHEN type = 'income' THEN amount ELSE -amount END), 0)
            FROM transactions WHERE account_id = ?
         ) WHERE id = ?",
    )
    .bind(account_id)
    .bind(account_id)
    .execute(&mut **db_txn)
    .await
    .map_err(|e| e.to_string())?;
    Ok(())
}
```

From DB schema (001_initial_schema.sql — debts table):

```sql
CREATE TABLE debts (
    id TEXT PRIMARY KEY,
    account_id TEXT NOT NULL REFERENCES accounts(id),
    description TEXT NOT NULL,
    original_amount INTEGER NOT NULL,
    total_installments INTEGER NOT NULL,
    paid_installments INTEGER NOT NULL DEFAULT 0,
    monthly_payment INTEGER NOT NULL,
    interest_rate REAL NOT NULL DEFAULT 0.0,
    start_date TEXT NOT NULL,
    is_active INTEGER NOT NULL DEFAULT 1,
    notes TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);
CREATE INDEX idx_debts_account ON debts(account_id);
CREATE INDEX idx_debts_active ON debts(is_active);
```

From src/lib/tauri.ts (existing invoke wrapper pattern):

```typescript
export const transactionApi = {
  list: (filters: TransactionFilters): Promise<PaginatedResult<Transaction>> =>
    invoke("list_transactions", { filter: filters }),
  create: (input: CreateTransactionInput): Promise<Transaction> =>
    invoke("create_transaction", { ... }),
  update: (id: string, input: UpdateTransactionInput): Promise<Transaction> =>
    invoke("update_transaction", { id, ...input }),
  delete: (id: string): Promise<void> =>
    invoke("delete_transaction", { id }),
};
```

From src/types/index.ts (existing TS type pattern):

```typescript
export interface Transaction {
  id: string;
  accountId: string;
  categoryId: string;
  amount: number;
  type: TransactionType;
  description: string;
  date: string;
  notes: string | null;
  createdAt: string;
}
```

</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQLite migration for installments table</name>
  <files>
    src-tauri/src/db/migrations/005_create_installments.sql
  </files>
  <action>
    Create the migration file `005_create_installments.sql`:

    ```sql
    -- Create installments table for per-installment debt tracking
    CREATE TABLE installments (
        id TEXT PRIMARY KEY,
        debt_id TEXT NOT NULL REFERENCES debts(id) ON DELETE CASCADE,
        installment_number INTEGER NOT NULL,
        due_date TEXT NOT NULL,
        amount INTEGER NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'paid')),
        actual_payment_date TEXT,
        transaction_id TEXT REFERENCES transactions(id),
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        UNIQUE(debt_id, installment_number)
    );

    CREATE INDEX idx_installments_debt ON installments(debt_id);
    CREATE INDEX idx_installments_status ON installments(status);
    CREATE INDEX idx_installments_due_date ON installments(due_date);
    ```

    Key design notes:
    - `status` stores only 'pending' or 'paid'. Overdue is derived at read time (due_date < today AND status = 'pending').
    - `transaction_id` links to the auto-created expense transaction when marked as paid (audit trail).
    - `ON DELETE CASCADE` ensures deleting a debt removes its installments.
    - `UNIQUE(debt_id, installment_number)` prevents duplicate installment numbers per debt.
    - `amount` is per-installment in minor currency units (INTEGER).
  </action>
  <verify>
    <automated>ls -la src-tauri/src/db/migrations/005_create_installments.sql && echo "Migration file exists"</automated>
  </verify>
  <done>Migration file exists with installments table, 3 indices, status CHECK constraint, CASCADE delete, and unique constraint on (debt_id, installment_number).</done>
</task>

<task type="auto">
  <name>Task 2: Rust models for debts and installments</name>
  <files>
    src-tauri/src/db/models.rs
  </files>
  <action>
    **In models.rs**, add these structs after the existing BalanceSummary struct:

    1. `Debt` struct with `#[derive(Debug, FromRow, Serialize, Deserialize, Clone)]` and `#[serde(rename_all = "camelCase")]`. Fields: `id: String`, `account_id: String`, `description: String`, `original_amount: i64`, `total_installments: i32`, `paid_installments: i32`, `monthly_payment: i64`, `interest_rate: f64`, `start_date: String`, `is_active: i32`, `notes: Option<String>`, `created_at: String`.

    2. `Installment` struct with same derives. Fields: `id: String`, `debt_id: String`, `installment_number: i32`, `due_date: String`, `amount: i64`, `status: String` (pending/paid), `actual_payment_date: Option<String>`, `transaction_id: Option<String>`, `created_at: String`.

    3. `DebtFilter` struct with `#[derive(Debug, Deserialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `account_id: Option<String>`, `is_active: Option<bool>`, `search: Option<String>`.

    4. `DebtWithInstallments` struct with `#[derive(Debug, Serialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `debt: Debt`, `installments: Vec<Installment>`, `account_name: String`, `next_due_date: Option<String>`, `remaining_amount: i64`.

    5. `CreditUtilization` struct with `#[derive(Debug, Serialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `account_id: String`, `account_name: String`, `credit_limit: i64`, `current_balance: i64`, `remaining_debt_commitments: i64`, `available_credit: i64`.

    6. `MonthlyProjection` struct with `#[derive(Debug, Serialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `month: String` (YYYY-MM format), `debts: Vec<DebtProjectionEntry>`, `total: i64`.

    7. `DebtProjectionEntry` struct with `#[derive(Debug, Serialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `debt_id: String`, `debt_description: String`, `amount: i64`.

    8. `CreateDebtInput` struct with `#[derive(Debug, Deserialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `account_id: String`, `description: String`, `original_amount: i64`, `total_installments: i32`, `monthly_payment: i64`, `interest_rate: f64`, `start_date: String`, `notes: Option<String>`.

    9. `UpdateDebtInput` struct with `#[derive(Debug, Deserialize)]` and `#[serde(rename_all = "camelCase")]`. Fields: `description: Option<String>`, `interest_rate: Option<f64>`, `is_active: Option<bool>`, `notes: Option<String>`.
    Note: Only allow editing metadata fields. original_amount, total_installments, monthly_payment, start_date, account_id are NOT editable after creation (would invalidate existing installments).
  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>All 9 debt-related structs compile. Debt and Installment use FromRow for sqlx queries. DebtWithInstallments composes Debt + installments for detail view. CreditUtilization and MonthlyProjection ready for projection queries.</done>
</task>

<task type="auto">
  <name>Task 3: Rust queries for debts and installments</name>
  <files>
    src-tauri/src/db/queries/debts.rs
    src-tauri/src/db/queries/mod.rs
  </files>
  <action>
    **In queries/debts.rs**, create the queries module:

    1. `get_debt_by_id(pool, id) -> Result<Option<Debt>>` — SELECT all debt fields. For `paid_installments`, use a subquery: `(SELECT COUNT(*) FROM installments WHERE debt_id = debts.id AND status = 'paid') as paid_installments`. This replaces the stored counter with a computed value.

    2. `list_debts(pool, filter: &DebtFilter) -> Result<Vec<Debt>>` — SELECT debts with computed paid_installments subquery. Use QueryBuilder pattern for dynamic WHERE: filter by account_id, is_active, search (LIKE on description). ORDER BY created_at DESC.

    3. `create_debt(pool, id, input: &CreateDebtInput) -> Result<Debt>` — INSERT into debts table then get_debt_by_id. Set paid_installments to 0 on insert.

    4. `update_debt(pool, id, input: &UpdateDebtInput) -> Result<Debt>` — UPDATE only provided fields (description, interest_rate, is_active, notes). Use QueryBuilder to build SET clause dynamically. Then get_debt_by_id.

    5. `delete_debt(pool, id) -> Result<()>` — DELETE FROM debts WHERE id = ?. CASCADE handles installments.

    6. `list_installments_for_debt(pool, debt_id) -> Result<Vec<Installment>>` — SELECT all from installments WHERE debt_id = ? ORDER BY installment_number ASC.

    7. `get_installment_by_id(pool, id) -> Result<Option<Installment>>` — standard get by id.

    8. `create_installment(pool, id, debt_id, installment_number, due_date, amount) -> Result<Installment>` — INSERT with status='pending'. Used during debt creation to auto-generate all installments.

    9. `update_installment_paid(pool, id, actual_payment_date, transaction_id) -> Result<Installment>` — UPDATE SET status='paid', actual_payment_date=?, transaction_id=? WHERE id=?. Then get_installment_by_id.

    10. `get_account_name_for_debt(pool, debt_id) -> Result<String>` — JOIN debts with accounts to get account name.

    **In queries/mod.rs**, add `pub mod debts;`.

    **IMPORTANT:** The `paid_installments` field on the `Debt` struct is computed via subquery in `get_debt_by_id` and `list_debts`. The column in the debts table still exists but is not relied upon -- the SELECT query computes it from the installments table for accuracy.
  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>All 10 query functions compile. list_debts uses QueryBuilder for dynamic filtering. paid_installments computed from installments table via subquery. queries/mod.rs exports debts module.</done>
</task>

<task type="auto">
  <name>Task 4: Rust commands for debt lifecycle, mark-as-paid, credit utilization, and projections</name>
  <files>
    src-tauri/src/commands/debts.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    **In commands/debts.rs**, create 8 Tauri commands:

    1. `create_debt(pool, input: CreateDebtInput) -> Result<DebtWithInstallments, String>`:
       - Validate: account_id exists and is active, original_amount > 0, total_installments > 0, monthly_payment > 0, start_date non-empty.
       - Generate UUID for debt.
       - Look up account to get `billing_day` (if credit card) or None.
       - Calculate due dates for each installment:
         - Determine day-of-month: use `billing_day` if account has one, otherwise extract day from `start_date`.
         - For each installment i (1..=total_installments), compute date: start from start_date month, add i months, clamp day to last day of target month (e.g., day 31 in February -> Feb 28/29).
         - Use chrono::NaiveDate for date arithmetic. Parse start_date as NaiveDate, iterate months.
       - Begin SQL transaction.
       - INSERT debt row.
       - INSERT all installment rows (each with unique UUID, computed due_date, amount = monthly_payment).
       - Commit.
       - Return DebtWithInstallments with debt, all installments, account_name, next_due_date (first pending due_date), remaining_amount (SUM of pending installment amounts).

    2. `update_debt(pool, id: String, input: UpdateDebtInput) -> Result<Debt, String>`:
       - Validate debt exists.
       - Call queries::debts::update_debt.
       - Return updated debt.

    3. `delete_debt(pool, id: String) -> Result<(), String>`:
       - Validate debt exists.
       - DELETE (CASCADE handles installments).
       - Note: auto-created transactions remain (they represent real money movements).

    4. `list_debts(pool, filter: DebtFilter) -> Result<Vec<Debt>, String>`:
       - Call queries::debts::list_debts.

    5. `get_debt_detail(pool, id: String) -> Result<DebtWithInstallments, String>`:
       - Fetch debt by id (error if not found).
       - Fetch all installments for this debt.
       - Get account name.
       - Compute next_due_date: first installment where status='pending' ordered by due_date.
       - Compute remaining_amount: SUM of amount for pending installments.
       - Return DebtWithInstallments.

    6. `mark_installment_paid(pool, installment_id: String, category_id: String) -> Result<Installment, String>`:
       - Fetch installment (error if not found, error if already paid).
       - Fetch the debt to get account_id.
       - Validate category exists, is active, and is of type 'expense'.
       - Validate account is active.
       - Begin SQL transaction:
         a. INSERT a new expense transaction (uuid, account_id from debt, category_id from param, amount from installment, type='expense', description="Pago cuota {N} - {debt_description}", date=today).
         b. UPDATE installment: status='paid', actual_payment_date=today (YYYY-MM-DD), transaction_id=new_txn_id.
         c. Recalculate account balance using the same `recalculate_account_balance` pattern from transactions.rs. Copy the helper function to debts.rs or make it accessible (simplest: duplicate the 5-line helper, as it's just a single SQL statement).
         d. UPDATE debts SET paid_installments = (SELECT COUNT(*) FROM installments WHERE debt_id = ? AND status = 'paid') WHERE id = ? (keep the denormalized counter in sync).
       - Commit.
       - Return updated installment.

    7. `get_credit_utilization(pool) -> Result<Vec<CreditUtilization>, String>`:
       - Query all active credit-card accounts (type='credit_card' AND is_active=1 AND credit_limit IS NOT NULL).
       - For each: get balance (current amount owed), credit_limit.
       - Get remaining_debt_commitments: SUM of installment.amount WHERE installment.status='pending' for active debts linked to this account.
       - available_credit = credit_limit - balance (this is the simple available credit based on current balance).
       - Return Vec<CreditUtilization>.

    8. `get_payment_projections(pool) -> Result<Vec<MonthlyProjection>, String>`:
       - Query pending installments for active debts, due in the next 6 months:
         ```sql
         SELECT i.debt_id, d.description, strftime('%Y-%m', i.due_date) as month, SUM(i.amount) as total
         FROM installments i
         JOIN debts d ON i.debt_id = d.id
         WHERE i.status = 'pending'
           AND i.due_date >= date('now')
           AND i.due_date < date('now', '+6 months')
           AND d.is_active = 1
         GROUP BY i.debt_id, d.description, month
         ORDER BY month, d.description
         ```
       - Group results into Vec<MonthlyProjection> where each MonthlyProjection has a month, a Vec<DebtProjectionEntry>, and a total (sum of all debt amounts for that month).

    **In commands/mod.rs**, add `pub mod debts;`.

    **In lib.rs**, add all 8 commands to `tauri::generate_handler![]`:
    ```
    commands::debts::create_debt,
    commands::debts::update_debt,
    commands::debts::delete_debt,
    commands::debts::list_debts,
    commands::debts::get_debt_detail,
    commands::debts::mark_installment_paid,
    commands::debts::get_credit_utilization,
    commands::debts::get_payment_projections,
    ```

    **Date arithmetic dependency:** The `chrono` crate is needed for due date calculation. Add `chrono = "0.4"` to Cargo.toml dependencies if not already present. Use `NaiveDate::parse_from_str` to parse start_date, then iterate months using `NaiveDate::with_month()` and date clamping.
  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>All 8 commands compile and are registered in lib.rs. create_debt auto-generates installment rows with billing_day-derived due dates. mark_installment_paid uses pool.begin()/commit() for atomic installment update + transaction insert + balance recalculation. get_credit_utilization returns data for credit-card accounts only. get_payment_projections returns 6-month lookahead grouped by month and debt.</done>
</task>

<task type="auto">
  <name>Task 5: TypeScript types and invoke wrappers for debts</name>
  <files>
    src/types/index.ts
    src/lib/tauri.ts
  </files>
  <action>
    **In types/index.ts**, add after the existing BalanceSummary interface:

    ```typescript
    export interface Debt {
      id: string;
      accountId: string;
      description: string;
      originalAmount: number;
      totalInstallments: number;
      paidInstallments: number;
      monthlyPayment: number;
      interestRate: number;
      startDate: string;
      isActive: number;
      notes: string | null;
      createdAt: string;
    }

    export type InstallmentStatus = "pending" | "paid";
    export type InstallmentDisplayStatus = "pagado" | "pendiente" | "vencido";

    export interface Installment {
      id: string;
      debtId: string;
      installmentNumber: number;
      dueDate: string;
      amount: number;
      status: InstallmentStatus;
      actualPaymentDate: string | null;
      transactionId: string | null;
      createdAt: string;
    }

    export interface DebtWithInstallments {
      debt: Debt;
      installments: Installment[];
      accountName: string;
      nextDueDate: string | null;
      remainingAmount: number;
    }

    export interface CreateDebtInput {
      accountId: string;
      description: string;
      originalAmount: number;
      totalInstallments: number;
      monthlyPayment: number;
      interestRate: number;
      startDate: string;
      notes?: string;
    }

    export interface UpdateDebtInput {
      description?: string;
      interestRate?: number;
      isActive?: boolean;
      notes?: string;
    }

    export interface DebtFilter {
      accountId?: string | null;
      isActive?: boolean | null;
      search?: string | null;
    }

    export interface CreditUtilization {
      accountId: string;
      accountName: string;
      creditLimit: number;
      currentBalance: number;
      remainingDebtCommitments: number;
      availableCredit: number;
    }

    export interface DebtProjectionEntry {
      debtId: string;
      debtDescription: string;
      amount: number;
    }

    export interface MonthlyProjection {
      month: string;
      debts: DebtProjectionEntry[];
      total: number;
    }
    ```

    **In lib/tauri.ts**, add imports for new types and create `debtApi`:

    ```typescript
    export const debtApi = {
      list: (filter: DebtFilter): Promise<Debt[]> =>
        invoke("list_debts", { filter }),

      getDetail: (id: string): Promise<DebtWithInstallments> =>
        invoke("get_debt_detail", { id }),

      create: (input: CreateDebtInput): Promise<DebtWithInstallments> =>
        invoke("create_debt", { input }),

      update: (id: string, input: UpdateDebtInput): Promise<Debt> =>
        invoke("update_debt", { id, input }),

      delete: (id: string): Promise<void> =>
        invoke("delete_debt", { id }),

      markInstallmentPaid: (installmentId: string, categoryId: string): Promise<Installment> =>
        invoke("mark_installment_paid", { installmentId, categoryId }),

      getCreditUtilization: (): Promise<CreditUtilization[]> =>
        invoke("get_credit_utilization"),

      getPaymentProjections: (): Promise<MonthlyProjection[]> =>
        invoke("get_payment_projections"),
    };
    ```
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>All TypeScript types compile. debtApi has 8 methods matching the 8 Tauri commands. Type shapes match Rust serde(rename_all=camelCase) serialization. InstallmentDisplayStatus type available for UI rendering.</done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` — Rust compiles with all models, queries, commands, and migration
2. `npx tsc --noEmit` — TypeScript compiles with all new types and API wrappers
3. Verify migration: `cat src-tauri/src/db/migrations/005_create_installments.sql` contains CREATE TABLE installments with CASCADE, status CHECK, and unique constraint
4. Verify commands registered: grep for `commands::debts::` in src-tauri/src/lib.rs (should find 8 entries)
5. Verify atomic mark-as-paid: grep for `pool.begin()` in commands/debts.rs
6. Verify due date calculation: grep for `chrono` or `NaiveDate` in commands/debts.rs
</verification>

<success_criteria>

- Rust backend compiles with 8 registered Tauri commands for debt lifecycle
- Migration creates installments table with proper FK, CASCADE, and constraints
- create_debt auto-generates installment rows with due dates derived from billing_day
- mark_installment_paid atomically creates expense transaction + updates installment + recalculates balance
- paid_installments on debts is computed from installments table (not a stale counter)
- Credit utilization queries only credit-card accounts (those with credit_limit)
- Payment projections return 6-month lookahead grouped by month and debt
- TypeScript types and invoke wrappers compile and match Rust shapes

</success_criteria>

<output>
After completion, create `.planning/phases/04-debts/04-01-SUMMARY.md`
</output>
