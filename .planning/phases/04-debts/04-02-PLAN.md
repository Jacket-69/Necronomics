---
phase: 04-debts
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - src/stores/debtStore.ts
  - src/components/debts/DebtFormModal.tsx
  - src/components/debts/MarkPaidModal.tsx
autonomous: true
requirements:
  - DEBT-01
  - DEBT-03

must_haves:
  truths:
    - "Zustand debtStore manages debt list, loading state, error state, and filter state"
    - "DebtFormModal creates a new debt with all required fields (account, description, amount, installments, monthly payment, interest rate, start date)"
    - "DebtFormModal validates inputs with zod schema before submission"
    - "MarkPaidModal prompts user to select an expense category before marking an installment as paid"
    - "After creating a debt or marking an installment paid, the store refetches the debt list"
  artifacts:
    - path: "src/stores/debtStore.ts"
      provides: "Zustand store for debt state management"
      contains: "export const useDebtStore"
    - path: "src/components/debts/DebtFormModal.tsx"
      provides: "Create/edit debt modal with react-hook-form + zod validation"
      contains: "DebtFormModal"
    - path: "src/components/debts/MarkPaidModal.tsx"
      provides: "Category picker modal for marking installment as paid"
      contains: "MarkPaidModal"
  key_links:
    - from: "src/stores/debtStore.ts"
      to: "src/lib/tauri.ts"
      via: "debtApi invoke wrappers"
      pattern: "debtApi\\."
    - from: "src/components/debts/DebtFormModal.tsx"
      to: "src/stores/debtStore.ts"
      via: "useDebtStore for createDebt action"
      pattern: "useDebtStore"
    - from: "src/components/debts/MarkPaidModal.tsx"
      to: "src/lib/tauri.ts"
      via: "debtApi.markInstallmentPaid"
      pattern: "debtApi\\.markInstallmentPaid"
---

<objective>
Build the Zustand debt store and form modals: debtStore for state management, DebtFormModal for creating/editing debts, and MarkPaidModal for the mark-as-paid flow with category selection.

Purpose: Establish state management and user input flows so that the Debts page (Plan 03) can compose these components into the full page.
Output: Zustand store with CRUD actions, create/edit form modal, mark-as-paid modal with category picker.
</objective>

<execution_context>
@/home/jacket/.claude/get-shit-done/workflows/execute-plan.md
@/home/jacket/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-debts/04-RESEARCH.md
@.planning/phases/04-debts/04-CONTEXT.md
@.planning/phases/04-debts/04-01-SUMMARY.md

<interfaces>
<!-- Existing store and form modal patterns -->

From src/stores/transactionStore.ts (Zustand store pattern):

```typescript
import { create } from "zustand";
import { transactionApi } from "../lib/tauri";

interface TransactionState {
  transactions: Transaction[];
  total: number;
  totalPages: number;
  isLoading: boolean;
  error: string | null;
  filters: TransactionStoreFilters;
  fetchTransactions: () => Promise<void>;
  setFilters: (updates: Partial<TransactionStoreFilters>) => void;
  createTransaction: (input: CreateTransactionInput) => Promise<Transaction>;
  updateTransaction: (id: string, input: UpdateTransactionInput) => Promise<Transaction>;
  deleteTransaction: (id: string) => Promise<void>;
  resetFilters: () => void;
}

export const useTransactionStore = create<TransactionState>((set, get) => ({
  // Data
  transactions: [],
  total: 0,
  totalPages: 0,
  isLoading: false,
  error: null,
  filters: { ...DEFAULT_FILTERS },

  fetchTransactions: async () => {
    set({ isLoading: true, error: null });
    try {
      const { filters } = get();
      const result = await transactionApi.list(filters);
      set({ transactions: result.data, total: result.total, totalPages: result.totalPages, isLoading: false });
    } catch (e) {
      set({ error: String(e), isLoading: false });
    }
  },
  // ...CRUD actions that call api then refetch
}));
```

From src/components/transactions/TransactionFormModal.tsx (form modal pattern):

```typescript
// Uses react-hook-form + zodResolver
// Props: isOpen, onClose, editingTransaction (null for create)
// Form fields mapped to CreateTransactionInput / UpdateTransactionInput
// On submit: store.createTransaction or store.updateTransaction
// Dirty state guard with window.confirm on close
// Error display at form level
```

From src/components/categories/CategoryFormModal.tsx (modal + Controller pattern):

```typescript
// Uses Controller for custom input components (e.g., IconPicker)
// zodResolver(schema) for validation
// form.reset() on open with editing data or defaults
// Overlay + centered box layout
```

From src/types/index.ts (new types from Plan 01):

```typescript
export interface Debt { id, accountId, description, originalAmount, totalInstallments, paidInstallments, monthlyPayment, interestRate, startDate, isActive, notes, createdAt }
export interface Installment { id, debtId, installmentNumber, dueDate, amount, status, actualPaymentDate, transactionId, createdAt }
export interface DebtWithInstallments { debt, installments, accountName, nextDueDate, remainingAmount }
export interface CreateDebtInput { accountId, description, originalAmount, totalInstallments, monthlyPayment, interestRate, startDate, notes? }
export interface UpdateDebtInput { description?, interestRate?, isActive?, notes? }
export interface DebtFilter { accountId?, isActive?, search? }
export interface CreditUtilization { accountId, accountName, creditLimit, currentBalance, remainingDebtCommitments, availableCredit }
export interface MonthlyProjection { month, debts: DebtProjectionEntry[], total }
```

From src/lib/tauri.ts (debtApi from Plan 01):

```typescript
export const debtApi = {
  list, getDetail, create, update, delete, markInstallmentPaid, getCreditUtilization, getPaymentProjections
};
```

</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Zustand debtStore</name>
  <files>
    src/stores/debtStore.ts
  </files>
  <action>
    Create `src/stores/debtStore.ts` following the transactionStore pattern:

    ```typescript
    import { create } from "zustand";
    import { debtApi } from "../lib/tauri";
    import type {
      Debt,
      DebtWithInstallments,
      Installment,
      CreateDebtInput,
      UpdateDebtInput,
      DebtFilter,
      CreditUtilization,
      MonthlyProjection,
    } from "../types";

    interface DebtStoreFilters {
      accountId: string | null;
      isActive: boolean | null;
      search: string;
    }

    const DEFAULT_FILTERS: DebtStoreFilters = {
      accountId: null,
      isActive: true,  // Default to showing only active debts
      search: "",
    };

    interface DebtState {
      // Data
      debts: Debt[];
      isLoading: boolean;
      error: string | null;

      // Filters
      filters: DebtStoreFilters;

      // Credit utilization (loaded separately)
      creditUtilizations: CreditUtilization[];

      // Payment projections (loaded separately)
      projections: MonthlyProjection[];

      // Actions
      fetchDebts: () => Promise<void>;
      setFilters: (updates: Partial<DebtStoreFilters>) => void;
      resetFilters: () => void;
      createDebt: (input: CreateDebtInput) => Promise<DebtWithInstallments>;
      updateDebt: (id: string, input: UpdateDebtInput) => Promise<Debt>;
      deleteDebt: (id: string) => Promise<void>;
      getDebtDetail: (id: string) => Promise<DebtWithInstallments>;
      markInstallmentPaid: (installmentId: string, categoryId: string) => Promise<Installment>;
      fetchCreditUtilizations: () => Promise<void>;
      fetchProjections: () => Promise<void>;
    }

    export const useDebtStore = create<DebtState>((set, get) => ({
      debts: [],
      isLoading: false,
      error: null,
      filters: { ...DEFAULT_FILTERS },
      creditUtilizations: [],
      projections: [],

      fetchDebts: async () => {
        set({ isLoading: true, error: null });
        try {
          const { filters } = get();
          const apiFilter: DebtFilter = {
            accountId: filters.accountId,
            isActive: filters.isActive,
            search: filters.search || null,
          };
          const debts = await debtApi.list(apiFilter);
          set({ debts, isLoading: false });
        } catch (e) {
          set({ error: String(e), isLoading: false });
        }
      },

      setFilters: (updates) => {
        set((state) => ({
          filters: { ...state.filters, ...updates },
        }));
      },

      resetFilters: () => {
        set({ filters: { ...DEFAULT_FILTERS } });
      },

      createDebt: async (input) => {
        const result = await debtApi.create(input);
        await get().fetchDebts();
        return result;
      },

      updateDebt: async (id, input) => {
        const result = await debtApi.update(id, input);
        await get().fetchDebts();
        return result;
      },

      deleteDebt: async (id) => {
        await debtApi.delete(id);
        await get().fetchDebts();
      },

      getDebtDetail: async (id) => {
        return await debtApi.getDetail(id);
      },

      markInstallmentPaid: async (installmentId, categoryId) => {
        const result = await debtApi.markInstallmentPaid(installmentId, categoryId);
        await get().fetchDebts();
        return result;
      },

      fetchCreditUtilizations: async () => {
        try {
          const creditUtilizations = await debtApi.getCreditUtilization();
          set({ creditUtilizations });
        } catch (e) {
          // Non-critical, log but don't block
          console.error("Failed to fetch credit utilizations:", e);
        }
      },

      fetchProjections: async () => {
        try {
          const projections = await debtApi.getPaymentProjections();
          set({ projections });
        } catch (e) {
          console.error("Failed to fetch projections:", e);
        }
      },
    }));
    ```

    Key differences from transactionStore:
    - No pagination (debts are typically a small list, not paginated).
    - Default filter `isActive: true` shows only active debts.
    - Separate fetch methods for credit utilizations and projections (loaded independently).
    - `getDebtDetail` returns full detail with installments (not stored in list state).
    - After markInstallmentPaid, refetch debts (paid_installments count changes).
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>debtStore compiles with all actions. fetchDebts uses DebtFilter. createDebt/updateDebt/deleteDebt/markInstallmentPaid all refetch after mutation. Separate fetchCreditUtilizations and fetchProjections for independent loading.</done>
</task>

<task type="auto">
  <name>Task 2: DebtFormModal (create/edit debt)</name>
  <files>
    src/components/debts/DebtFormModal.tsx
  </files>
  <action>
    Create `src/components/debts/DebtFormModal.tsx` following the TransactionFormModal pattern:

    **Props:** `isOpen: boolean`, `onClose: () => void`, `editingDebt: Debt | null` (null = create mode, non-null = edit mode).

    **Zod schema (z4 pattern with message param):**
    ```typescript
    const debtSchema = z.object({
      accountId: z.string().min(1, "La cuenta es obligatoria"),
      description: z.string().min(1, "La descripcion es obligatoria"),
      originalAmount: z.string().min(1, "El monto es obligatorio"),     // String in form, convert on submit
      totalInstallments: z.string().min(1, "El numero de cuotas es obligatorio"),
      monthlyPayment: z.string().min(1, "El monto por cuota es obligatorio"),
      interestRate: z.string().optional(),
      startDate: z.string().min(1, "La fecha de inicio es obligatoria"),
      notes: z.string().optional(),
    });
    ```

    **Form setup:**
    - `useForm` with `zodResolver(debtSchema)`.
    - Reset form on open: if editingDebt, populate fields from debt data (converting amounts from minor units to human-readable). If creating, set startDate to today, interestRate to "0".
    - Account dropdown: fetch accounts from accountStore (useAccountStore). Show all active accounts.

    **Layout (consistent with existing modal pattern):**
    - Overlay + centered box.
    - Title: "Nueva Deuda" or "Editar Deuda".
    - Fields:
      - Account selector (dropdown of active accounts).
      - Description (text input).
      - Original Amount (number input — represents total debt amount in human-readable units).
      - Total Installments (number input — integer, e.g., 12).
      - Monthly Payment (number input — amount per installment in human-readable units).
      - Interest Rate (number input — percentage, e.g., 1.5 for 1.5%).
      - Start Date (date input, default today).
      - Notes (optional textarea).
    - Buttons: "Cancelar" / "Crear Deuda" or "Guardar Cambios".
    - Dirty state guard: window.confirm on close if form is dirty.
    - Form-level error display below the form.

    **On submit (create mode):**
    - Convert originalAmount and monthlyPayment from human-readable to minor units using `toMinorUnits` from formatters.ts. Use the selected account's currency decimal places.
    - Call `debtStore.createDebt(input)`.
    - On success, close modal.
    - On error, display error in form.

    **On submit (edit mode):**
    - Only description, interestRate, notes are editable (per UpdateDebtInput).
    - Call `debtStore.updateDebt(id, input)`.
    - On success, close modal.

    **Styling:** Use the same inline styles as TransactionFormModal — Lovecraftian dark theme (#0a0f06, #111a0a, #2a3518, #4a5d23, #7fff00, Share Tech Mono font).

    **Note on edit mode:** In edit mode, disable/hide accountId, originalAmount, totalInstallments, monthlyPayment, startDate fields (not editable after creation — would invalidate existing installments). Only show description, interestRate, notes as editable.
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>DebtFormModal compiles. Create mode shows all fields, edit mode shows only editable fields. Zod validation on all required fields. Amount conversion from human-readable to minor units on submit. Dirty state guard on close. Consistent Lovecraftian styling.</done>
</task>

<task type="auto">
  <name>Task 3: MarkPaidModal (category picker for marking installment paid)</name>
  <files>
    src/components/debts/MarkPaidModal.tsx
  </files>
  <action>
    Create `src/components/debts/MarkPaidModal.tsx`:

    **Props:** `isOpen: boolean`, `onClose: () => void`, `installment: Installment | null`, `debtDescription: string`, `onConfirm: (categoryId: string) => Promise<void>`.

    **Purpose:** When the user clicks "Marcar como pagada" on a pending installment, this modal appears asking them to select an expense category. On confirm, it calls the parent's onConfirm handler (which calls debtStore.markInstallmentPaid).

    **Layout:**
    - Overlay + centered box (same pattern as DeleteTransactionModal).
    - Title: "Marcar Cuota como Pagada".
    - Info text: "Cuota {installment.installmentNumber} de {debtDescription}".
    - Amount display: formatted amount of the installment.
    - Category dropdown: fetch expense categories from categoryStore. Filter to type='expense' only. Group by parent if subcategories exist.
    - Buttons: "Cancelar" / "Confirmar Pago".
    - Loading state on confirm button while processing.
    - Error display if markInstallmentPaid fails.

    **Behavior:**
    - Category selection is required (cannot confirm without selecting).
    - On confirm: call `onConfirm(selectedCategoryId)`, which is wired to `debtStore.markInstallmentPaid(installment.id, categoryId)` in the parent.
    - On success: close modal. Parent component will refetch debt detail to update installment list.
    - On error: show error message in the modal, keep modal open.

    **Styling:** Same Lovecraftian dark theme as other modals.
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>MarkPaidModal compiles. Shows installment info + category picker. Category dropdown filtered to expense type. Confirm calls onConfirm with selected categoryId. Loading and error states handled. Consistent modal styling.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — All TypeScript files compile
2. Verify store pattern: debtStore exports useDebtStore with fetchDebts, createDebt, updateDebt, deleteDebt, markInstallmentPaid, fetchCreditUtilizations, fetchProjections
3. Verify form validation: DebtFormModal uses zodResolver with required field validation
4. Verify category filtering: MarkPaidModal only shows expense categories
5. Verify dirty state guard: DebtFormModal uses window.confirm on close when form is dirty
</verification>

<success_criteria>

- debtStore manages debts, creditUtilizations, projections state with independent fetch methods
- DebtFormModal creates debts with all required fields, validates with zod, converts amounts to minor units
- DebtFormModal edit mode only allows editing description, interestRate, notes (not structure fields)
- MarkPaidModal requires expense category selection before confirming payment
- All components follow established modal and styling patterns
- TypeScript compiles without errors

</success_criteria>

<output>
After completion, create `.planning/phases/04-debts/04-02-SUMMARY.md`
</output>
