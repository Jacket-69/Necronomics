---
phase: 02-categories
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/db/migrations/004_migrate_category_icons.sql
  - src-tauri/src/db/mod.rs
  - src-tauri/src/db/models.rs
  - src-tauri/src/db/queries/categories.rs
  - src-tauri/src/db/queries/mod.rs
  - src-tauri/src/commands/categories.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/types/index.ts
  - src/lib/tauri.ts
autonomous: true
requirements: [CATE-01, CATE-02, CATE-03, CATE-04]

must_haves:
  truths:
    - "Categories can be created with name, type (income/expense), icon, and optional parent"
    - "Categories can be updated (name, type, parent, icon)"
    - "Categories with linked transactions cannot be deleted"
    - "Parent categories cascade delete to subcategories (blocked if any has transactions)"
    - "Subcategory type change cascades from parent"
    - "Type change blocked if category or any subcategory has linked transactions"
    - "Existing seed category icons are Lucide icon names, not emojis"
  artifacts:
    - path: "src-tauri/src/db/migrations/004_migrate_category_icons.sql"
      provides: "Migration converting emoji icons to Lucide icon names"
    - path: "src-tauri/src/db/queries/categories.rs"
      provides: "SQL queries for all category CRUD operations"
      exports:
        [
          "get_all",
          "get_by_id",
          "create",
          "update",
          "delete",
          "has_transactions",
          "get_subcategories",
          "count_transactions",
        ]
    - path: "src-tauri/src/commands/categories.rs"
      provides: "Tauri IPC command handlers for categories"
    - path: "src/types/index.ts"
      provides: "Category, CreateCategoryInput, UpdateCategoryInput TypeScript types"
    - path: "src/lib/tauri.ts"
      provides: "categoryApi invoke wrappers"
  key_links:
    - from: "src-tauri/src/commands/categories.rs"
      to: "src-tauri/src/db/queries/categories.rs"
      via: "function calls"
      pattern: "categories::(get_all|create|update|delete)"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/categories.rs"
      via: "invoke_handler registration"
      pattern: "commands::categories::"
    - from: "src/lib/tauri.ts"
      to: "Tauri IPC"
      via: "invoke() calls"
      pattern: "invoke\\('(list|get|create|update|delete)_categor"
---

<objective>
Build the complete Rust backend for categories (model, queries, commands) and the TypeScript types + invoke wrappers. Also migrate seed category icons from emojis to Lucide icon names.

Purpose: Establish the data layer and IPC contracts that the frontend (Plans 02 and 03) will consume.
Output: Working Tauri commands for category CRUD, TypeScript types, and invoke wrappers ready for UI integration.
</objective>

<execution_context>
@/home/jacket/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/jacket/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-categories/02-CONTEXT.md

<interfaces>
<!-- Existing patterns from Phase 1 that MUST be followed exactly -->

From src-tauri/src/db/models.rs:

```rust
// Follow this exact derive/serde pattern for Category model
#[derive(Debug, FromRow, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Account {
    pub id: String,
    pub name: String,
    #[sqlx(rename = "type")]
    #[serde(rename = "type")]
    pub account_type: String,
    // ...
}
```

From src-tauri/src/db/queries/accounts.rs:

```rust
// Follow this exact query pattern
pub async fn get_all(pool: &SqlitePool) -> Result<Vec<Account>, sqlx::Error> {
    sqlx::query_as::<_, Account>("SELECT ... FROM accounts ...").fetch_all(pool).await
}
```

From src-tauri/src/commands/accounts.rs:

```rust
// Follow this exact command pattern
#[tauri::command]
pub async fn list_accounts(pool: State<'_, SqlitePool>) -> Result<Vec<Account>, String> {
    accounts::get_all(&pool).await.map_err(|e| e.to_string())
}
```

From src/types/index.ts:

```typescript
export type AccountType = "cash" | "bank" | "credit_card";
export interface Account {
  id: string;
  name: string;
  type: AccountType /* ... */;
}
export interface CreateAccountInput {
  name: string;
  accountType: AccountType /* ... */;
}
```

From src/lib/tauri.ts:

```typescript
import { invoke } from '@tauri-apps/api/core';
export const accountApi = {
  list: (): Promise<Account[]> => invoke('list_accounts'),
  create: (input: CreateAccountInput): Promise<Account> => invoke('create_account', { ... }),
  // ...
};
```

From src-tauri/src/db/migrations/001_initial_schema.sql (categories table):

```sql
CREATE TABLE categories (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('income', 'expense')),
    icon TEXT,
    parent_id TEXT REFERENCES categories(id),
    is_active INTEGER NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(name, parent_id, type)
);
```

</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create icon migration, Category model, and SQL queries</name>
  <files>
    src-tauri/src/db/migrations/004_migrate_category_icons.sql
    src-tauri/src/db/mod.rs
    src-tauri/src/db/models.rs
    src-tauri/src/db/queries/categories.rs
    src-tauri/src/db/queries/mod.rs
  </files>
  <action>
    **1. Create migration 004_migrate_category_icons.sql** to convert emoji icon values to Lucide icon names. Map each seed category emoji to a Lucide icon name:
    - Alimentacion: ğŸ½ï¸ â†’ "utensils"
    - Supermercado: ğŸ›’ â†’ "shopping-cart"
    - Comida Rapida: ğŸ” â†’ "sandwich"
    - Restaurant: ğŸ· â†’ "wine"
    - Delivery: ğŸ“¦ â†’ "package"
    - Transporte: ğŸšŒ â†’ "bus"
    - Micro/Metro: ğŸš‡ â†’ "train-front"
    - Uber/Taxi: ğŸš• â†’ "car-taxi-front"
    - Bencina: â›½ â†’ "fuel"
    - Vivienda: ğŸ  â†’ "home"
    - Arriendo: ğŸ”‘ â†’ "key-round"
    - Servicios Basicos: ğŸ’¡ â†’ "lightbulb"
    - Internet: ğŸŒ â†’ "globe"
    - Entretenimiento: ğŸ® â†’ "gamepad-2"
    - Streaming: ğŸ“º â†’ "tv"
    - Juegos: ğŸ•¹ï¸ â†’ "joystick"
    - Salidas: ğŸ» â†’ "beer"
    - Salud: ğŸ¥ â†’ "hospital"
    - Farmacia: ğŸ’Š â†’ "pill"
    - Consulta Medica: ğŸ©º â†’ "stethoscope"
    - Educacion: ğŸ“š â†’ "book-open"
    - Ropa: ğŸ‘• â†’ "shirt"
    - Otros (expense): ğŸ“‹ â†’ "clipboard-list"
    - Sueldo: ğŸ’° â†’ "wallet"
    - Sueldo Base: ğŸ’µ â†’ "banknote"
    - Bonos: ğŸ â†’ "gift"
    - Horas Extra: â° â†’ "clock"
    - Freelance: ğŸ’» â†’ "laptop"
    - Inversiones: ğŸ“ˆ â†’ "trending-up"
    - Otros (income): ğŸ“‹ â†’ "clipboard-list"

    Use UPDATE statements with WHERE id = 'cat_xxx' for each category. One UPDATE per line.

    **2. Register migration in src-tauri/src/db/mod.rs** â€” add the 004 entry to the migrations vec following the existing pattern: `("004_migrate_category_icons", include_str!("migrations/004_migrate_category_icons.sql"))`.

    **3. Add Category model to src-tauri/src/db/models.rs** â€” follow the exact same derive/serde pattern as Account:
    ```rust
    #[derive(Debug, FromRow, Serialize, Deserialize, Clone)]
    #[serde(rename_all = "camelCase")]
    pub struct Category {
        pub id: String,
        pub name: String,
        #[sqlx(rename = "type")]
        #[serde(rename = "type")]
        pub category_type: String,
        pub icon: Option<String>,
        pub parent_id: Option<String>,
        pub is_active: i32,
        pub created_at: String,
    }
    ```

    **4. Create src-tauri/src/db/queries/categories.rs** with these functions (follow accounts.rs query pattern exactly):

    - `get_all(pool) -> Vec<Category>` â€” SELECT all active categories, ORDER BY type, parent_id NULLS FIRST, name. This returns ALL categories (parents and subs) in a flat list; the frontend will group them.
    - `get_by_id(pool, id) -> Option<Category>` â€” single category fetch
    - `create(pool, id, name, category_type, icon, parent_id) -> Category` â€” INSERT and return
    - `update(pool, id, name, category_type, icon, parent_id) -> Category` â€” update mutable fields. Fetch existing first to preserve unchanged values (same pattern as accounts update).
    - `delete(pool, id) -> ()` â€” DELETE FROM categories WHERE id = ?
    - `get_subcategories(pool, parent_id) -> Vec<Category>` â€” SELECT children of a parent
    - `has_transactions(pool, category_id) -> bool` â€” COUNT(*) FROM transactions WHERE category_id = ?
    - `count_transactions(pool, category_id) -> i64` â€” return actual count (for UI message "tiene N transacciones")
    - `update_subcategory_types(pool, parent_id, new_type) -> ()` â€” UPDATE categories SET type = ? WHERE parent_id = ?

    **5. Register module** â€” add `pub mod categories;` to src-tauri/src/db/queries/mod.rs.

  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>Category model compiles, all query functions compile, migration file exists, module registered in queries/mod.rs and db/mod.rs</done>
</task>

<task type="auto">
  <name>Task 2: Create Tauri commands, TypeScript types, and invoke wrappers</name>
  <files>
    src-tauri/src/commands/categories.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
    src/types/index.ts
    src/lib/tauri.ts
  </files>
  <action>
    **1. Create src-tauri/src/commands/categories.rs** with these commands (follow accounts.rs command pattern exactly â€” `State<'_, SqlitePool>`, `Result<T, String>`, `.map_err(|e| e.to_string())`):

    - `list_categories(pool) -> Vec<Category>` â€” calls categories::get_all
    - `get_category(pool, id) -> Category` â€” calls categories::get_by_id, returns error "Categoria no encontrada: {id}" if None
    - `create_category(pool, name, category_type, icon, parent_id)` â€” validate: if parent_id provided, fetch parent and verify parent exists + has no parent itself (single-level nesting enforced). Generate UUID id. If parent_id provided, inherit type from parent and ignore passed category_type. Return created Category.
    - `update_category(pool, id, name, category_type, icon, parent_id)` â€” Business logic:
      - Fetch existing category
      - If type is changing: check if category or any subcategory has transactions (block with "No se puede cambiar el tipo de una categoria con transacciones vinculadas"). If no transactions, cascade type change to all subcategories via update_subcategory_types.
      - If parent_id is changing: verify the category itself is not a parent (has subcategories â†’ block with "No se puede mover una categoria padre a otra categoria"). Also enforce same-type constraint (new parent must match category type, or block).
      - Cannot set parent_id if category has subcategories (would create sub-sub-categories)
    - `delete_category(pool, id) -> ()` â€” Business logic:
      - Check if category has transactions â†’ block with "Esta categoria tiene N transacciones vinculadas. Reasigna las transacciones a otra categoria antes de eliminar."
      - If category is a parent: check ALL subcategories for transactions. If any has transactions â†’ block with same message mentioning the subcategory name. If none have transactions â†’ delete all subcategories first, then delete parent.
      - Return () on success.

    **2. Register module** â€” add `pub mod categories;` to src-tauri/src/commands/mod.rs.

    **3. Register commands in src-tauri/src/lib.rs** â€” add to invoke_handler:
    ```
    commands::categories::list_categories,
    commands::categories::get_category,
    commands::categories::create_category,
    commands::categories::update_category,
    commands::categories::delete_category,
    ```

    **4. Add TypeScript types to src/types/index.ts** â€” append after existing types:
    ```typescript
    export type CategoryType = "income" | "expense";

    export interface Category {
      id: string;
      name: string;
      type: CategoryType;
      icon: string | null;
      parentId: string | null;
      isActive: number;
      createdAt: string;
    }

    export interface CreateCategoryInput {
      name: string;
      categoryType: CategoryType;
      icon: string | null;
      parentId: string | null;
    }

    export interface UpdateCategoryInput {
      name?: string;
      categoryType?: CategoryType;
      icon?: string | null;
      parentId?: string | null;
    }
    ```

    **5. Add categoryApi to src/lib/tauri.ts** â€” append after currencyApi, following same pattern:
    ```typescript
    export const categoryApi = {
      list: (): Promise<Category[]> => invoke("list_categories"),
      get: (id: string): Promise<Category> => invoke("get_category", { id }),
      create: (input: CreateCategoryInput): Promise<Category> =>
        invoke("create_category", {
          name: input.name,
          categoryType: input.categoryType,
          icon: input.icon,
          parentId: input.parentId,
        }),
      update: (id: string, input: UpdateCategoryInput): Promise<Category> =>
        invoke("update_category", { id, ...input }),
      delete: (id: string): Promise<void> => invoke("delete_category", { id }),
    };
    ```
    Import Category, CreateCategoryInput, UpdateCategoryInput from types.

  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5 && cd .. && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>All 5 Tauri category commands compile and are registered in invoke_handler. TypeScript types and categoryApi invoke wrappers compile. Frontend can call list/get/create/update/delete operations.</done>
</task>

</tasks>

<verification>
- `cargo check` passes with no errors
- `npx tsc --noEmit` passes with no errors
- Category model follows same derive pattern as Account model
- All 5 commands registered in invoke_handler
- Migration 004 registered in migration runner
</verification>

<success_criteria>

- Rust backend compiles with complete category CRUD
- TypeScript compiles with Category types and invoke wrappers
- Existing seed categories will have Lucide icon names after migration runs
- Business rules implemented: single-level nesting, type cascade, transaction-link deletion guard
  </success_criteria>

<output>
After completion, create `.planning/phases/02-categories/02-01-SUMMARY.md`
</output>
