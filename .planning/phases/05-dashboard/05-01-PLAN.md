---
phase: 05-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/db/models.rs
  - src-tauri/src/db/queries/dashboard.rs
  - src-tauri/src/db/queries/mod.rs
  - src-tauri/src/commands/dashboard.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/types/index.ts
  - src/lib/tauri.ts
autonomous: true
requirements:
  - DASH-01
  - DASH-02
  - DASH-03
  - DASH-04

must_haves:
  truths:
    - "get_dashboard_data command returns balance summary with consolidated total and per-account balances"
    - "get_dashboard_data command returns current-month income and expense totals converted to base currency"
    - "get_dashboard_data command returns top 5 expense categories plus Otros grouping, with parent rollup"
    - "get_dashboard_data command returns 10 most recent transactions with account and category names"
  artifacts:
    - path: "src-tauri/src/db/queries/dashboard.rs"
      provides: "SQL queries for dashboard metrics"
      exports:
        ["get_monthly_income_expense", "get_top_spending_categories", "get_recent_transactions"]
    - path: "src-tauri/src/commands/dashboard.rs"
      provides: "Tauri IPC command for dashboard data"
      exports: ["get_dashboard_data"]
    - path: "src/types/index.ts"
      provides: "TypeScript types for dashboard data"
      contains: "DashboardData"
    - path: "src/lib/tauri.ts"
      provides: "dashboardApi invoke wrapper"
      contains: "dashboardApi"
  key_links:
    - from: "src-tauri/src/commands/dashboard.rs"
      to: "src-tauri/src/db/queries/dashboard.rs"
      via: "function calls"
      pattern: "queries::dashboard::"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/dashboard.rs"
      via: "invoke_handler registration"
      pattern: "commands::dashboard::get_dashboard_data"
    - from: "src/lib/tauri.ts"
      to: "get_dashboard_data command"
      via: "invoke IPC"
      pattern: "invoke.*get_dashboard_data"
---

<objective>
Create the Rust backend data layer and TypeScript contract for the dashboard page. A single `get_dashboard_data` Tauri command provides all four dashboard metrics in one IPC call: balance summary, monthly income/expense, top spending categories, and recent transactions.

Purpose: Establish the data pipeline so Plan 02 can build the UI against typed, working data.
Output: Rust models, SQL queries, Tauri command, TypeScript types, and API wrapper.
</objective>

<execution_context>
@/home/jacket/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/jacket/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dashboard/05-CONTEXT.md

@src-tauri/src/db/models.rs
@src-tauri/src/db/queries/mod.rs
@src-tauri/src/db/queries/transactions.rs
@src-tauri/src/commands/transactions.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/lib.rs
@src/types/index.ts
@src/lib/tauri.ts
@src/lib/formatters.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src-tauri/src/db/models.rs (reuse these existing types):

```rust
pub struct AccountBalance {
    pub account_id: String,
    pub account_name: String,
    pub balance: i64,
    pub currency_code: String,
}

pub struct BalanceSummary {
    pub accounts: Vec<AccountBalance>,
    pub consolidated_total: Option<i64>,
    pub base_currency_code: String,
}
```

From src-tauri/src/commands/transactions.rs (balance consolidation pattern to replicate):

```rust
// Fetches active accounts with currency, then loops to convert via exchange_rates table
let accounts: Vec<(String, String, i64, String)> = sqlx::query_as(
    "SELECT a.id, a.name, a.balance, c.code
     FROM accounts a JOIN currencies c ON a.currency_id = c.id
     WHERE a.is_active = 1",
).fetch_all(pool.inner()).await.map_err(|e| e.to_string())?;
// Then for non-base currencies, looks up exchange rate and converts
```

From src/types/index.ts (existing TS balance types):

```typescript
export interface BalanceSummary {
  accounts: AccountBalance[];
  consolidatedTotal: number | null;
  baseCurrencyCode: string;
}
```

From src/lib/tauri.ts (API wrapper pattern):

```typescript
export const transactionApi = {
  getBalanceSummary: (baseCurrencyId?: string): Promise<BalanceSummary> =>
    invoke("get_balance_summary", { baseCurrencyId: baseCurrencyId ?? null }),
};
```

</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rust dashboard models, queries, and command</name>
  <files>
    src-tauri/src/db/models.rs
    src-tauri/src/db/queries/dashboard.rs
    src-tauri/src/db/queries/mod.rs
    src-tauri/src/commands/dashboard.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
**1. Add dashboard models to `src-tauri/src/db/models.rs`:**

Add these structs at the end of the file:

```rust
/// Dashboard aggregate data returned by the get_dashboard_data command.
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DashboardData {
    pub balance_summary: BalanceSummary,
    pub monthly_income_expense: MonthlyIncomeExpense,
    pub top_categories: Vec<CategorySpending>,
    pub recent_transactions: Vec<RecentTransaction>,
}

/// Income and expense totals for the current month, converted to base currency.
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct MonthlyIncomeExpense {
    pub income: i64,
    pub expense: i64,
    pub month_name: String,
    pub year: i32,
}

/// A category's spending amount and proportion of total spending for the month.
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CategorySpending {
    pub category_id: String,
    pub category_name: String,
    pub amount: i64,
    pub percentage: f64,
}

/// A recent transaction with joined account and category names for display.
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct RecentTransaction {
    pub id: String,
    pub account_name: String,
    pub category_name: String,
    pub amount: i64,
    pub transaction_type: String,
    pub description: String,
    pub date: String,
}
```

**2. Create `src-tauri/src/db/queries/dashboard.rs`:**

Three query functions, all taking `&SqlitePool`:

- `get_monthly_transactions(pool) -> Vec<(i64, String, String)>`:
  Fetch all transactions for the current month with their currency code. SQL:

  ```sql
  SELECT t.amount, t.type, cur.code as currency_code
  FROM transactions t
  JOIN accounts a ON t.account_id = a.id
  JOIN currencies cur ON a.currency_id = cur.id
  WHERE t.date >= date('now', 'start of month')
    AND t.date < date('now', 'start of month', '+1 month')
  ```

  Returns `Vec<(i64, String, String)>` — (amount, type, currency_code). Use `query_as` with tuple.

- `get_category_spending(pool) -> Vec<(String, String, i64, String)>`:
  Fetch expense transactions for current month grouped by parent category (subcategories roll up). SQL:

  ```sql
  SELECT
    COALESCE(parent.id, c.id) as category_id,
    COALESCE(parent.name, c.name) as category_name,
    t.amount,
    cur.code as currency_code
  FROM transactions t
  JOIN categories c ON t.category_id = c.id
  LEFT JOIN categories parent ON c.parent_id = parent.id
  JOIN accounts a ON t.account_id = a.id
  JOIN currencies cur ON a.currency_id = cur.id
  WHERE t.type = 'expense'
    AND t.date >= date('now', 'start of month')
    AND t.date < date('now', 'start of month', '+1 month')
  ```

  Returns individual rows (not grouped) — (category_id, category_name, amount, currency_code). Grouping and currency conversion happens in the command layer so exchange rates can be applied per-row.

- `get_recent_transactions(pool) -> Vec<RecentTransaction>`:
  NOT using the RecentTransaction model directly (it has serde derives but not FromRow). Instead use a tuple or a dedicated FromRow struct. SQL:

  ```sql
  SELECT
    t.id, a.name as account_name, c.name as category_name,
    t.amount, t.type as transaction_type, t.description, t.date
  FROM transactions t
  JOIN accounts a ON t.account_id = a.id
  JOIN categories c ON t.category_id = c.id
  ORDER BY t.date DESC, t.created_at DESC
  LIMIT 10
  ```

  Return a `Vec<(String, String, String, i64, String, String, String)>` tuple or add `#[derive(FromRow)]` to a local struct and map to `RecentTransaction`.

- `get_current_month_info(pool) -> (i32, i32)`:
  ```sql
  SELECT CAST(strftime('%m', 'now') AS INTEGER), CAST(strftime('%Y', 'now') AS INTEGER)
  ```
  Returns (month_number, year).

Register module: add `pub mod dashboard;` to `src-tauri/src/db/queries/mod.rs`.

**3. Create `src-tauri/src/commands/dashboard.rs`:**

Single command `get_dashboard_data`:

```rust
#[tauri::command]
pub async fn get_dashboard_data(
    pool: State<'_, SqlitePool>,
) -> Result<DashboardData, String> { ... }
```

Implementation steps inside the command:

a) **Balance summary**: Replicate the pattern from `commands/transactions.rs::get_balance_summary`. Fetch active accounts with currencies, build `Vec<AccountBalance>`, compute consolidated total using exchange rates from the `exchange_rates` table. Use `base_cur_id = "cur_clp"` as default (same as existing). This produces a `BalanceSummary`.

b) **Monthly income/expense**: Call `queries::dashboard::get_monthly_transactions(pool.inner())`. For each row, convert amount to base currency using the same exchange rate lookup pattern (look up rate from `exchange_rates` table if currency != base). Sum income and expense separately. Get month/year from `get_current_month_info`. Map month number to Spanish name using a helper:

```rust
fn spanish_month_name(month: i32) -> &'static str {
    match month {
        1 => "Enero", 2 => "Febrero", 3 => "Marzo", 4 => "Abril",
        5 => "Mayo", 6 => "Junio", 7 => "Julio", 8 => "Agosto",
        9 => "Septiembre", 10 => "Octubre", 11 => "Noviembre",
        12 => "Diciembre", _ => "Desconocido",
    }
}
```

Build `MonthlyIncomeExpense { income, expense, month_name, year }`.

c) **Top spending categories**: Call `queries::dashboard::get_category_spending(pool.inner())`. For each row, convert amount to base currency. Then group by category_id in a `HashMap<String, (String, i64)>` (name, accumulated_amount). Sort descending by amount. Take top 5 entries. Sum remaining into an "Otros" entry (category_id = "otros", category_name = "Otros"). Calculate percentage = (amount \* 100) / total_spending for each. Build `Vec<CategorySpending>`. If no transactions, return empty vec. If <= 5 categories, no "Otros" entry needed.

d) **Recent transactions**: Call `queries::dashboard::get_recent_transactions(pool.inner())`. Map query results into `Vec<RecentTransaction>`. These display raw amounts (no currency conversion — the UI shows amounts in their original currency, and the user decision says the recent transactions panel just shows "amount + type" which is the raw value).

Wait — re-reading the CONTEXT for recent transactions: "Each row displays: date, amount + type (income/expense), category, account name, description". No mention of currency conversion. The amounts are raw per-account currency. BUT the RecentTransaction model doesn't include currency code. Add `currency_code: String` to the RecentTransaction model so the frontend can format amounts correctly. Update the SQL to also select `cur.code as currency_code` by joining accounts → currencies.

**Updated RecentTransaction model:**

```rust
pub struct RecentTransaction {
    pub id: String,
    pub account_name: String,
    pub category_name: String,
    pub amount: i64,
    pub transaction_type: String,
    pub description: String,
    pub date: String,
    pub currency_code: String,  // For amount formatting
}
```

**Updated SQL for recent transactions:**

```sql
SELECT
  t.id, a.name, c.name, t.amount, t.type, t.description, t.date, cur.code
FROM transactions t
JOIN accounts a ON t.account_id = a.id
JOIN categories c ON t.category_id = c.id
JOIN currencies cur ON a.currency_id = cur.id
ORDER BY t.date DESC, t.created_at DESC
LIMIT 10
```

e) Combine all into `DashboardData` and return.

**Exchange rate caching**: The command needs exchange rates for both income/expense and category calculations. To avoid repeated DB lookups, pre-fetch all latest exchange rates into a `HashMap<String, f64>` (from_currency_code → rate_to_base) at the start of the command:

```sql
SELECT c.code, er.rate
FROM exchange_rates er
JOIN currencies c ON er.from_currency_id = c.id
WHERE er.to_currency_id = ?
  AND er.date = (SELECT MAX(date) FROM exchange_rates er2
                  WHERE er2.from_currency_id = er.from_currency_id
                    AND er2.to_currency_id = er.to_currency_id)
```

Then use this map for all conversions. If no rate exists for a currency, skip those amounts (same behavior as existing balance summary).

**4. Register the command:**

- Add `pub mod dashboard;` to `src-tauri/src/commands/mod.rs`
- Add `commands::dashboard::get_dashboard_data,` to the `invoke_handler` macro in `src-tauri/src/lib.rs`
  </action>
  <verify>
  <automated>cd src-tauri && cargo build 2>&1 | tail -5</automated>
  </verify>
  <done> - DashboardData, MonthlyIncomeExpense, CategorySpending, RecentTransaction models exist in models.rs - queries/dashboard.rs has 4 query functions - commands/dashboard.rs has get_dashboard_data command - Command registered in lib.rs invoke_handler - `cargo build` succeeds
  </done>
  </task>

<task type="auto">
  <name>Task 2: TypeScript dashboard types and API wrapper</name>
  <files>
    src/types/index.ts
    src/lib/tauri.ts
  </files>
  <action>
**1. Add dashboard types to `src/types/index.ts`:**

Add at the end of the file, after the existing `MonthlyProjection` interface:

```typescript
export interface DashboardData {
  balanceSummary: BalanceSummary;
  monthlyIncomeExpense: MonthlyIncomeExpense;
  topCategories: CategorySpending[];
  recentTransactions: RecentTransaction[];
}

export interface MonthlyIncomeExpense {
  income: number; // minor units in base currency
  expense: number; // minor units in base currency
  monthName: string; // Spanish month name (e.g., "Marzo")
  year: number;
}

export interface CategorySpending {
  categoryId: string;
  categoryName: string;
  amount: number; // minor units in base currency
  percentage: number; // 0-100
}

export interface RecentTransaction {
  id: string;
  accountName: string;
  categoryName: string;
  amount: number; // minor units in original currency
  transactionType: string; // "income" | "expense"
  description: string;
  date: string;
  currencyCode: string; // for formatting
}
```

These must exactly match the Rust serde `camelCase` serialization output.

**2. Add dashboardApi to `src/lib/tauri.ts`:**

Add the import for new types at the top (extend the existing import statement):

```typescript
import type {
  // ... existing imports ...
  DashboardData,
} from "../types";
```

Add after the `debtApi` object:

```typescript
export const dashboardApi = {
  getData: (): Promise<DashboardData> => invoke("get_dashboard_data"),
};
```

Follow the exact same pattern as existing API objects (accountApi, categoryApi, etc.).
</action>
<verify>
<automated>npx tsc --noEmit 2>&1 | tail -10</automated>
</verify>
<done> - DashboardData, MonthlyIncomeExpense, CategorySpending, RecentTransaction types exported from types/index.ts - dashboardApi.getData() available in tauri.ts - TypeScript compilation succeeds with no errors - Types match the expected Rust serde camelCase output shape
</done>
</task>

</tasks>

<verification>
- `cargo build` in src-tauri/ compiles without errors
- `npx tsc --noEmit` passes with no type errors
- The get_dashboard_data command is registered in lib.rs invoke_handler
- TypeScript types match Rust serde output (camelCase field names, same structure)
</verification>

<success_criteria>

- Backend returns all 4 dashboard metrics in a single IPC call
- Balance summary includes consolidated total with exchange rate conversion
- Monthly income/expense converts amounts to base currency
- Top categories groups by parent (subcategory rollup), returns top 5 + "Otros"
- Recent transactions returns 10 most recent with account/category names and currency codes
- TypeScript contract matches Rust output exactly
  </success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard/05-01-SUMMARY.md`
</output>
