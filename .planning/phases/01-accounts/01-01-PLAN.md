---
phase: 01-accounts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/types/index.ts
  - src/lib/tauri.ts
  - src/lib/formatters.ts
  - src-tauri/src/db/models.rs
  - src-tauri/src/db/mod.rs
  - src-tauri/src/db/queries/accounts.rs
  - src-tauri/src/db/queries/mod.rs
  - src-tauri/src/commands/accounts.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true
requirements:
  - ACCT-01
  - ACCT-02
  - ACCT-03
  - ACCT-04

must_haves:
  truths:
    - "Rust backend compiles with all 6 account commands registered"
    - "TypeScript types match the Rust Account struct serialization shape"
    - "Frontend invoke wrappers call every registered Tauri command by correct name"
    - "Currency formatter correctly handles CLP (0 decimals), USD/EUR/CNY (2 decimals), JPY (0 decimals)"
  artifacts:
    - path: "src-tauri/src/commands/accounts.rs"
      provides: "Tauri IPC commands: list, get, create, update, archive, delete"
      exports: ["list_accounts", "get_account", "create_account", "update_account", "archive_account", "delete_account"]
    - path: "src-tauri/src/db/models.rs"
      provides: "Account struct with sqlx::FromRow and serde derives"
      contains: "pub struct Account"
    - path: "src-tauri/src/db/queries/accounts.rs"
      provides: "SQL queries for all account operations"
      exports: ["get_all", "get_by_id", "create", "update", "archive", "delete", "has_transactions"]
    - path: "src/types/index.ts"
      provides: "Account, AccountType, Currency, CreateAccountInput, UpdateAccountInput types"
      exports: ["Account", "AccountType", "Currency", "CreateAccountInput", "UpdateAccountInput"]
    - path: "src/lib/tauri.ts"
      provides: "Typed invoke wrappers for account commands"
      exports: ["accountApi"]
    - path: "src/lib/formatters.ts"
      provides: "Currency formatting utility"
      exports: ["formatCurrency"]
  key_links:
    - from: "src-tauri/src/commands/accounts.rs"
      to: "src-tauri/src/db/queries/accounts.rs"
      via: "function calls from commands to query layer"
      pattern: "queries::accounts::"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/accounts.rs"
      via: "generate_handler! macro registration"
      pattern: "commands::accounts::"
    - from: "src/lib/tauri.ts"
      to: "src-tauri/src/commands/accounts.rs"
      via: "invoke() IPC bridge"
      pattern: "invoke\\('(list|get|create|update|archive|delete)_account"
---

<objective>
Build the complete foundation layer for Phase 1: install missing frontend dependencies, define TypeScript types and invoke wrappers, and implement the full Rust backend for account CRUD operations.

Purpose: Establish stable IPC contracts and data layer so that subsequent plans (store, UI) build against working, tested infrastructure.
Output: Compilable Rust backend with 6 registered Tauri commands, TypeScript type definitions matching the IPC contract, typed invoke wrappers, and a currency formatter.
</objective>

<execution_context>
@/home/jacket/.claude/get-shit-done/workflows/execute-plan.md
@/home/jacket/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-accounts/01-CONTEXT.md
@.planning/phases/01-accounts/01-RESEARCH.md
@src-tauri/src/lib.rs
@src-tauri/src/db/mod.rs
@src-tauri/src/db/queries/mod.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/db/migrations/001_initial_schema.sql
@src-tauri/src/db/migrations/002_seed_currencies.sql
@src-tauri/Cargo.toml
@package.json

<interfaces>
<!-- Database schema (source of truth for Account model) -->
From src-tauri/src/db/migrations/001_initial_schema.sql:
```sql
CREATE TABLE accounts (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('cash', 'bank', 'credit_card')),
    currency_id TEXT NOT NULL REFERENCES currencies(id),
    balance INTEGER NOT NULL DEFAULT 0,
    credit_limit INTEGER,
    billing_day INTEGER CHECK (billing_day BETWEEN 1 AND 31),
    is_active INTEGER NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

From src-tauri/src/db/migrations/002_seed_currencies.sql:
```sql
-- Currency IDs: 'cur_clp', 'cur_usd', 'cur_eur', 'cur_jpy', 'cur_cny'
-- Decimal places: CLP=0, USD=2, EUR=2, JPY=0, CNY=2
```

From src-tauri/src/db/mod.rs (existing pool setup):
```rust
pub mod queries;
// create_pool() returns SqlitePool, managed via app.manage(pool)
```

From src-tauri/src/lib.rs (existing setup):
```rust
mod commands;
mod db;
mod services;
// init_database creates pool and manages it
// run() builds tauri app — currently NO invoke_handler
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install frontend dependencies and create TypeScript foundation</name>
  <files>
    package.json
    src/types/index.ts
    src/lib/tauri.ts
    src/lib/formatters.ts
  </files>
  <action>
**Step 1: Install missing frontend dependencies.**
Run:
```bash
npm install zustand react-router @hookform/resolvers zod react-hook-form
```
Note: Install `react-router` (NOT `react-router-dom` — v7 is a unified package).

**Step 2: Create `src/types/index.ts`.**
Define the following types matching the Rust Account struct serialization (serde rename_all = "camelCase"):

```typescript
export type AccountType = 'cash' | 'bank' | 'credit_card';

export interface Account {
  id: string;
  name: string;
  type: AccountType;
  currencyId: string;
  balance: number;       // integer minor units (never float)
  creditLimit: number | null;
  billingDay: number | null;
  isActive: number;      // 1 or 0 (SQLite integer boolean)
  createdAt: string;
}

export interface CreateAccountInput {
  name: string;
  accountType: AccountType;
  currencyId: string;
  creditLimit?: number;
  billingDay?: number;
}

export interface UpdateAccountInput {
  name?: string;
  currencyId?: string;
  creditLimit?: number;
  billingDay?: number;
}

export interface Currency {
  id: string;
  code: string;
  name: string;
  symbol: string;
  decimalPlaces: number;
}
```

**Step 3: Create `src/lib/tauri.ts`.**
Typed invoke wrappers for all 6 account commands. Use `invoke` from `@tauri-apps/api/core`. Tauri auto-converts snake_case Rust params to camelCase on JS side. The wrapper functions must pass params exactly matching the Rust command parameter names (in camelCase).

```typescript
import { invoke } from '@tauri-apps/api/core';
import type { Account, CreateAccountInput, UpdateAccountInput, Currency } from '../types';

export const accountApi = {
  list: (): Promise<Account[]> =>
    invoke('list_accounts'),

  get: (id: string): Promise<Account> =>
    invoke('get_account', { id }),

  create: (input: CreateAccountInput): Promise<Account> =>
    invoke('create_account', {
      name: input.name,
      accountType: input.accountType,
      currencyId: input.currencyId,
      creditLimit: input.creditLimit ?? null,
      billingDay: input.billingDay ?? null,
    }),

  update: (id: string, input: UpdateAccountInput): Promise<Account> =>
    invoke('update_account', { id, ...input }),

  archive: (id: string): Promise<void> =>
    invoke('archive_account', { id }),

  delete: (id: string): Promise<void> =>
    invoke('delete_account', { id }),
};

export const currencyApi = {
  list: (): Promise<Currency[]> =>
    invoke('list_currencies'),
};
```

**Step 4: Create `src/lib/formatters.ts`.**
Currency formatter that converts integer minor units to localized display string. Use `es-CL` locale for number formatting.

```typescript
const CURRENCY_CONFIG: Record<string, { symbol: string; decimals: number }> = {
  CLP: { symbol: '$', decimals: 0 },
  USD: { symbol: 'US$', decimals: 2 },
  EUR: { symbol: '\u20AC', decimals: 2 },  // Euro sign
  JPY: { symbol: '\u00A5', decimals: 0 },  // Yen sign
  CNY: { symbol: '\u00A5', decimals: 2 },  // Yuan sign
};

export const formatCurrency = (minorUnits: number, currencyCode: string): string => {
  const config = CURRENCY_CONFIG[currencyCode] ?? { symbol: '', decimals: 2 };
  const amount = config.decimals === 0 ? minorUnits : minorUnits / Math.pow(10, config.decimals);
  return `${config.symbol}${amount.toLocaleString('es-CL', {
    minimumFractionDigits: config.decimals,
    maximumFractionDigits: config.decimals,
  })}`;
};

export const formatAccountType = (type: string): string => {
  const labels: Record<string, string> = {
    cash: 'Efectivo',
    bank: 'Banco',
    credit_card: 'Tarjeta de credito',
  };
  return labels[type] ?? type;
};
```
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics && npm ls zustand react-router react-hook-form zod @hookform/resolvers && npx tsc --noEmit src/types/index.ts src/lib/tauri.ts src/lib/formatters.ts</automated>
  </verify>
  <done>
    - zustand, react-router, react-hook-form, zod, @hookform/resolvers installed in package.json
    - src/types/index.ts exports Account, AccountType, Currency, CreateAccountInput, UpdateAccountInput
    - src/lib/tauri.ts exports accountApi with typed wrappers for 6 commands
    - src/lib/formatters.ts exports formatCurrency and formatAccountType
    - All TypeScript files compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Rust backend — models, queries, commands, and wiring</name>
  <files>
    src-tauri/src/db/models.rs
    src-tauri/src/db/mod.rs
    src-tauri/src/db/queries/accounts.rs
    src-tauri/src/db/queries/mod.rs
    src-tauri/src/commands/accounts.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
**Step 1: Create `src-tauri/src/db/models.rs` with Account struct.**

```rust
use serde::{Deserialize, Serialize};
use sqlx::FromRow;

/// Represents an account entity from the `accounts` table.
#[derive(Debug, FromRow, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Account {
    pub id: String,
    pub name: String,
    /// Mapped from the `type` column (Rust keyword). Use sqlx rename + serde rename.
    #[sqlx(rename = "type")]
    #[serde(rename = "type")]
    pub account_type: String,
    pub currency_id: String,
    pub balance: i64,
    pub credit_limit: Option<i64>,
    pub billing_day: Option<i32>,
    pub is_active: i32,
    pub created_at: String,
}

/// Represents a currency entity from the `currencies` table.
#[derive(Debug, FromRow, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Currency {
    pub id: String,
    pub code: String,
    pub name: String,
    pub symbol: String,
    pub decimal_places: i32,
    pub created_at: String,
}
```

**CRITICAL:** The `type` column is a Rust keyword. The struct field is named `account_type` with both `#[sqlx(rename = "type")]` (for query mapping) and `#[serde(rename = "type")]` (so JSON serializes as `type`). Combined with `#[serde(rename_all = "camelCase")]`, the serialized output will be `{ "type": "cash", "currencyId": "cur_clp", "isActive": 1, ... }`.

**Step 2: Update `src-tauri/src/db/mod.rs`.**
Add `pub mod models;` alongside existing `pub mod queries;`.

**Step 3: Create `src-tauri/src/db/queries/accounts.rs`.**
Implement all SQL query functions. Use `sqlx::query_as::<_, Account>()` (runtime, no macros). Never use `unwrap()` — return `Result<T, sqlx::Error>`.

Functions to implement:
- `get_all(pool) -> Vec<Account>`: SELECT all active accounts, ORDER BY type, name (per CONTEXT.md decision)
- `get_by_id(pool, id) -> Option<Account>`: SELECT by id (active or not)
- `create(pool, id, name, account_type, currency_id, credit_limit, billing_day) -> Account`: INSERT and return the created account
- `update(pool, id, name, currency_id, credit_limit, billing_day) -> Account`: UPDATE and return. Do NOT allow changing `type` (locked after creation per CONTEXT.md)
- `archive(pool, id)`: UPDATE SET is_active = 0
- `delete(pool, id)`: DELETE FROM accounts WHERE id = ?
- `has_transactions(pool, account_id) -> bool`: SELECT COUNT(*) FROM transactions WHERE account_id = ?

For `create`: Generate UUID with `uuid::Uuid::new_v4().to_string()`. INSERT the row, then SELECT it back with `get_by_id` to return the full Account.

For `update`: Execute UPDATE, then SELECT the updated row to return it.

**Step 4: Update `src-tauri/src/db/queries/mod.rs`.**
Add `pub mod accounts;` to the existing empty module.

**Step 5: Create `src-tauri/src/commands/accounts.rs`.**
Implement 6 Tauri commands + 1 helper command for currencies:

```rust
use sqlx::SqlitePool;
use tauri::State;
use crate::db::models::{Account, Currency};
use crate::db::queries::accounts;
```

Commands (all `pub async fn`, all take `pool: State<'_, SqlitePool>`, all return `Result<T, String>` mapping errors via `.map_err(|e| e.to_string())`):

1. `list_accounts(pool) -> Vec<Account>` — calls `accounts::get_all`
2. `get_account(pool, id: String) -> Account` — calls `accounts::get_by_id`, returns error if None
3. `create_account(pool, name, account_type, currency_id, credit_limit: Option<i64>, billing_day: Option<i32>) -> Account`
   - **Validate:** if `account_type == "credit_card"`, both `credit_limit` and `billing_day` must be `Some`. Return error string if not.
   - Call `accounts::create`
4. `update_account(pool, id, name: Option<String>, currency_id: Option<String>, credit_limit: Option<i64>, billing_day: Option<i32>) -> Account`
   - Fetch existing account first. If type is `credit_card`, validate that credit_limit and billing_day remain present after update.
   - Call `accounts::update`
5. `archive_account(pool, id: String)` — calls `accounts::archive`
6. `delete_account(pool, id: String)`
   - **CRITICAL:** Call `accounts::has_transactions` first. If true, return error "No se puede eliminar una cuenta con transacciones. Use archivar." (per CONTEXT.md: permanent delete blocked if transactions exist).
   - If no transactions, call `accounts::delete`
7. `list_currencies(pool) -> Vec<Currency>` — simple SELECT * FROM currencies query (for the account form currency dropdown)

**Step 6: Update `src-tauri/src/commands/mod.rs`.**
Add `pub mod accounts;`.

**Step 7: Update `src-tauri/src/lib.rs`.**
Add `.invoke_handler(tauri::generate_handler![...])` to the Tauri builder chain, BEFORE `.run(...)`. Register ALL 7 commands:

```rust
.invoke_handler(tauri::generate_handler![
    commands::accounts::list_accounts,
    commands::accounts::get_account,
    commands::accounts::create_account,
    commands::accounts::update_account,
    commands::accounts::archive_account,
    commands::accounts::delete_account,
    commands::accounts::list_currencies,
])
```

This MUST be a single `invoke_handler` call — multiple calls overwrite previous registrations.
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics/src-tauri && cargo check 2>&1</automated>
  </verify>
  <done>
    - `cargo check` passes with no errors
    - Account struct has correct sqlx and serde renames for the `type` column
    - All 7 commands registered in a single invoke_handler call in lib.rs
    - create_account validates credit_card required fields
    - delete_account blocks deletion when transactions exist
    - No `unwrap()` calls in any command or query code
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes — Rust backend compiles with all commands registered
2. `npx tsc --noEmit` passes — TypeScript types and wrappers compile
3. `npm ls zustand react-router react-hook-form zod @hookform/resolvers` — all deps installed
4. `grep -c "generate_handler" src-tauri/src/lib.rs` returns 1 — single handler registration
5. `grep -c "unwrap()" src-tauri/src/commands/accounts.rs src-tauri/src/db/queries/accounts.rs` returns 0
</verification>

<success_criteria>
- Rust project compiles with zero errors and zero `unwrap()` in production code
- TypeScript project compiles with zero errors
- 6 account commands + 1 currency command registered in Tauri invoke_handler
- Frontend types match the Rust serialization shape (camelCase with `type` field)
- All 5 frontend packages installed and resolvable
</success_criteria>

<output>
After completion, create `.planning/phases/01-accounts/01-01-SUMMARY.md`
</output>
