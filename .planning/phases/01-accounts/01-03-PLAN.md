---
phase: 01-accounts
plan: 03
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - src/pages/NewAccountPage.tsx
  - src/pages/EditAccountPage.tsx
  - src/components/accounts/AccountForm.tsx
  - src/components/accounts/ConfirmDeleteModal.tsx
  - src/App.tsx
  - src/pages/AccountsPage.tsx
  - src/components/accounts/AccountList.tsx
autonomous: false
requirements:
  - ACCT-01
  - ACCT-02
  - ACCT-03

must_haves:
  truths:
    - "User can create a cash, bank, or credit-card account via a form with name, type, and currency fields"
    - "Credit-card account creation requires credit limit and billing day fields"
    - "User can edit account name and currency; account type is locked after creation"
    - "Credit-card account edit always shows credit limit and billing day fields"
    - "User can archive an account from the list and sees a success toast"
    - "User can permanently delete an account only if it has no transactions, after typed confirmation"
    - "Permanent delete is blocked with a clear message when transactions exist"
    - "After create/archive/delete, user is returned to accounts list"
  artifacts:
    - path: "src/components/accounts/AccountForm.tsx"
      provides: "Shared create/edit form with react-hook-form + Zod validation"
      exports: ["AccountForm"]
      min_lines: 80
    - path: "src/components/accounts/ConfirmDeleteModal.tsx"
      provides: "Archive and typed-confirmation delete modal"
      exports: ["ConfirmDeleteModal"]
      min_lines: 50
    - path: "src/pages/NewAccountPage.tsx"
      provides: "New account page wrapping AccountForm in create mode"
      exports: ["NewAccountPage"]
    - path: "src/pages/EditAccountPage.tsx"
      provides: "Edit account page wrapping AccountForm in edit mode with pre-populated data"
      exports: ["EditAccountPage"]
  key_links:
    - from: "src/components/accounts/AccountForm.tsx"
      to: "src/stores/accountStore.ts"
      via: "addAccount and updateAccount store actions"
      pattern: "useAccountStore"
    - from: "src/components/accounts/ConfirmDeleteModal.tsx"
      to: "src/stores/accountStore.ts"
      via: "archiveAccount and deleteAccount store actions"
      pattern: "useAccountStore"
    - from: "src/pages/NewAccountPage.tsx"
      to: "src/components/accounts/AccountForm.tsx"
      via: "renders AccountForm in create mode"
      pattern: "AccountForm"
    - from: "src/pages/EditAccountPage.tsx"
      to: "src/components/accounts/AccountForm.tsx"
      via: "renders AccountForm in edit mode with defaultValues"
      pattern: "AccountForm.*mode.*edit"
    - from: "src/App.tsx"
      to: "src/pages/NewAccountPage.tsx"
      via: "react-router route /accounts/new"
      pattern: "NewAccountPage"
---

<objective>
Implement the account create/edit form with conditional credit-card validation and the archive/delete confirmation modal with transaction-blocking delete logic.

Purpose: Complete the account lifecycle UI — create, edit, archive, and delete — wiring all user-facing flows to the Rust backend through the Zustand store.
Output: Working account create and edit forms, a two-path confirmation modal (archive/delete), and full end-to-end account management flow.
</objective>

<execution_context>
@/home/jacket/.claude/get-shit-done/workflows/execute-plan.md
@/home/jacket/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-accounts/01-CONTEXT.md
@.planning/phases/01-accounts/01-RESEARCH.md
@.planning/phases/01-accounts/01-01-SUMMARY.md
@.planning/phases/01-accounts/01-02-SUMMARY.md

<interfaces>
<!-- From Plan 01 and Plan 02 outputs -->

From src/types/index.ts:
```typescript
export type AccountType = 'cash' | 'bank' | 'credit_card';
export interface Account {
  id: string; name: string; type: AccountType; currencyId: string;
  balance: number; creditLimit: number | null; billingDay: number | null;
  isActive: number; createdAt: string;
}
export interface CreateAccountInput {
  name: string; accountType: AccountType; currencyId: string;
  creditLimit?: number; billingDay?: number;
}
export interface UpdateAccountInput {
  name?: string; currencyId?: string; creditLimit?: number; billingDay?: number;
}
export interface Currency {
  id: string; code: string; name: string; symbol: string; decimalPlaces: number;
}
```

From src/stores/accountStore.ts:
```typescript
export const useAccountStore: () => {
  accounts: Account[];
  currencies: Currency[];
  isLoading: boolean;
  error: string | null;
  fetchAccounts: () => Promise<void>;
  fetchCurrencies: () => Promise<void>;
  addAccount: (input: CreateAccountInput) => Promise<Account>;
  updateAccount: (id: string, input: UpdateAccountInput) => Promise<Account>;
  archiveAccount: (id: string) => Promise<void>;
  deleteAccount: (id: string) => Promise<void>;
};
```

From src/lib/formatters.ts:
```typescript
export const formatAccountType = (type: string): string;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AccountForm with conditional credit-card validation</name>
  <files>
    src/components/accounts/AccountForm.tsx
    src/pages/NewAccountPage.tsx
    src/pages/EditAccountPage.tsx
    src/App.tsx
  </files>
  <action>
**Step 1: Create `src/components/accounts/AccountForm.tsx`.**

This is the core form component, shared between create and edit modes. Uses `react-hook-form` with `zodResolver` for validation.

**Zod schema:**
```typescript
import { z } from 'zod';

const accountSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100, 'Maximo 100 caracteres'),
  accountType: z.enum(['cash', 'bank', 'credit_card'], {
    errorMap: () => ({ message: 'Selecciona un tipo de cuenta' }),
  }),
  currencyId: z.string().min(1, 'La moneda es requerida'),
  creditLimit: z.number().positive('Debe ser mayor que 0').optional().nullable(),
  billingDay: z.number().int().min(1, 'Minimo 1').max(31, 'Maximo 31').optional().nullable(),
}).superRefine((data, ctx) => {
  if (data.accountType === 'credit_card') {
    if (!data.creditLimit) {
      ctx.addIssue({ code: 'custom', path: ['creditLimit'], message: 'Requerido para tarjeta de credito' });
    }
    if (!data.billingDay) {
      ctx.addIssue({ code: 'custom', path: ['billingDay'], message: 'Requerido para tarjeta de credito' });
    }
  }
});
```

**Props:**
```typescript
interface AccountFormProps {
  mode: 'create' | 'edit';
  defaultValues?: Partial<AccountFormData>;
  accountId?: string;  // Only in edit mode
  lockedType?: boolean;  // true in edit mode — disables accountType field
  onSuccess: () => void;  // Called after successful submit (navigation)
}
```

**Form behavior (per CONTEXT.md locked decisions):**
- `mode: 'onBlur'` — validation runs on field blur
- Account type selector: 3 options rendered as radio buttons or select — `Efectivo`, `Banco`, `Tarjeta de credito`
- When `accountType` changes (watched via `watch('accountType')`), show/hide credit-card fields dynamically
- Credit-card fields: "Limite de credito" (number input) and "Dia de facturacion" (number input 1-31)
- In edit mode, `accountType` field is disabled (locked after creation per CONTEXT.md)
- Currency: Select dropdown populated from `useAccountStore().currencies`. Call `fetchCurrencies()` on mount.
- Default currency: `'cur_clp'` (hardcoded for Phase 1; Phase 6 will make this configurable)
- Submit-level error summary: If any errors exist after submit attempt, display all error messages in a red-bordered summary div above the submit button (per CONTEXT.md: "submit-level error summary")
- On submit in create mode: call `useAccountStore().addAccount(input)`, on success call `onSuccess()` (which navigates to /accounts)
- On submit in edit mode: call `useAccountStore().updateAccount(accountId, input)`, on success call `onSuccess()`
- Submit button text: "Crear cuenta" in create mode, "Guardar cambios" in edit mode
- Cancel button: navigates back to /accounts

**Register fields using RHF `register()` (uncontrolled inputs).** Use `{ valueAsNumber: true }` for creditLimit and billingDay.

**Styling:** Use TailwindCSS. Form on dark background. Input fields: dark background (`#111a0a`), moss-green border, light text. Labels in Spanish. Focus ring in chartreuse (`#7fff00`).

**Step 2: Create `src/pages/NewAccountPage.tsx`.**

Simple page that renders `AccountForm` in create mode.
- Title: "Nueva Cuenta"
- `onSuccess` navigates to `/accounts` via `useNavigate()`
- Default currency preset to `'cur_clp'`

**Step 3: Create `src/pages/EditAccountPage.tsx`.**

Page that loads an existing account and renders `AccountForm` in edit mode.
- Get account ID from URL param via `useParams()`
- Fetch the account via `useAccountStore().accounts.find(a => a.id === id)` or call `accountApi.get(id)` if not in store
- Show loading state while fetching
- Show error if account not found
- Pre-populate `defaultValues` from the existing account data:
  ```typescript
  {
    name: account.name,
    accountType: account.type,
    currencyId: account.currencyId,
    creditLimit: account.creditLimit ?? undefined,
    billingDay: account.billingDay ?? undefined,
  }
  ```
- Set `lockedType: true` to disable account type field
- `onSuccess` navigates to `/accounts`

**Step 4: Update `src/App.tsx` route definitions.**

Replace the placeholder routes from Plan 02:
- `/accounts/new` now renders `NewAccountPage`
- `/accounts/:id/edit` now renders `EditAccountPage`
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics && npx tsc --noEmit && npm run build 2>&1 | head -30</automated>
  </verify>
  <done>
    - AccountForm renders in create mode with name, type, currency, and conditional credit-card fields
    - AccountForm renders in edit mode with pre-populated data and locked account type
    - Zod schema validates credit_limit and billing_day as required when type is credit_card
    - Validation runs on blur and shows submit-level error summary
    - NewAccountPage and EditAccountPage render correctly at their routes
    - Successful create/edit navigates back to /accounts
    - TypeScript compiles and Vite builds without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ConfirmDeleteModal and wire archive/delete actions in AccountList</name>
  <files>
    src/components/accounts/ConfirmDeleteModal.tsx
    src/components/accounts/AccountList.tsx
    src/pages/AccountsPage.tsx
  </files>
  <action>
**Step 1: Create `src/components/accounts/ConfirmDeleteModal.tsx`.**

A modal component with two paths per CONTEXT.md locked decisions:

**Props:**
```typescript
interface ConfirmDeleteModalProps {
  account: Account;
  isOpen: boolean;
  onClose: () => void;
  onArchived: () => void;  // Called after successful archive
  onDeleted: () => void;   // Called after successful delete
}
```

**Two-path behavior:**

**Path 1 — Archive (primary action):**
- Always available
- Simple confirmation: "Archivar {account.name}? La cuenta se ocultara de la lista pero los datos se conservaran."
- "Archivar" button calls `useAccountStore().archiveAccount(account.id)`, then `onArchived()`
- This is the primary/recommended destructive path

**Path 2 — Permanent delete (secondary, guarded):**
- A secondary section below archive: "Eliminar permanentemente"
- If the delete call fails with the "has transactions" error from the backend, display the error message: "Esta cuenta tiene transacciones asociadas. Solo se puede archivar."
- If delete is allowed (no transactions), require **typed confirmation**: user must type the exact account name into an input field before the delete button enables.
- The typed-confirmation input: `<input>` with placeholder text "Escribe el nombre de la cuenta para confirmar"
- Delete button (`"Eliminar"`) disabled until `typedName === account.name`
- On delete: call `useAccountStore().deleteAccount(account.id)`. If error (transactions exist), show the error. If success, call `onDeleted()`.

**Modal styling:**
- Overlay: semi-transparent dark backdrop
- Modal box: dark background (`#111a0a`), subtle border, centered
- Archive button: moss green background
- Delete button: red/danger color, only enabled when typed confirmation matches
- Close button (X) in top-right corner

**Step 2: Update `src/components/accounts/AccountList.tsx`.**

Wire the placeholder edit/archive buttons from Plan 02 to real functionality:
- Edit button: navigate to `/accounts/{id}/edit` via `useNavigate()`
- Archive button: open `ConfirmDeleteModal` with the selected account
- Add a "Mas acciones" overflow menu (or just show all actions inline for Phase 1): Edit, Archivar, Eliminar
  - For simplicity in Phase 1, show Edit and a "..." menu or all actions inline
  - Clicking "Archivar" or "Eliminar" opens the ConfirmDeleteModal

Manage modal state:
```typescript
const [selectedAccount, setSelectedAccount] = useState<Account | null>(null);
const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
```

**Step 3: Update `src/pages/AccountsPage.tsx`.**

- After successful archive or delete (via modal callbacks), show a **success toast**. Per CONTEXT.md: "After archive/delete action, return to accounts list and show success toast."
- For Phase 1, implement a simple toast as a temporary notification div that auto-dismisses after 3 seconds:
  ```typescript
  const [toast, setToast] = useState<string | null>(null);
  // After archive: setToast('Cuenta archivada exitosamente');
  // After delete: setToast('Cuenta eliminada exitosamente');
  // Auto-dismiss: useEffect with setTimeout clearing toast after 3s
  ```
- Toast styling: fixed position bottom-right, dark background with chartreuse border, auto-fade.
- Refetch accounts after archive/delete to refresh the list (the store should handle this, but call `fetchAccounts()` as a safety measure).
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics && npx tsc --noEmit && npm run build 2>&1 | head -30</automated>
  </verify>
  <done>
    - ConfirmDeleteModal shows archive path (always available) and delete path (typed confirmation)
    - Delete is blocked with error message when account has transactions
    - Typed confirmation required: user must type exact account name before delete enables
    - AccountList edit buttons navigate to /accounts/:id/edit
    - AccountList archive/delete buttons open ConfirmDeleteModal
    - Success toast appears after archive or delete actions
    - Toast auto-dismisses after 3 seconds
    - TypeScript compiles and Vite builds without errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete account lifecycle flow</name>
  <files>n/a — verification only</files>
  <action>
    This is a human-verify checkpoint. What was built:
    Complete account management: create (all 3 types), edit (with locked type), archive, and delete (with transaction guard and typed confirmation). Accounts list with desktop table and mobile card layouts, formatted balances, and success toasts.

    How to verify:
    1. Run `npm run tauri dev` from the project root
    2. The app should load and navigate to /accounts
    3. Click "Nueva cuenta" — the create form should appear
    4. Create a cash account: enter name, select "Efectivo", select "CLP" currency, submit
    5. Verify redirect to /accounts with the new account in the list
    6. Create a credit-card account: select "Tarjeta de credito", verify credit limit and billing day fields appear, fill all fields, submit
    7. Verify both accounts appear in the list with correct types and formatted balances ($0 for CLP)
    8. Click "Editar" on an account — verify form is pre-populated and account type is disabled/locked
    9. Change the name, save — verify redirect to list with updated name
    10. Click "Archivar" on an account — confirm in modal — verify account disappears from list and success toast appears
    11. For the delete flow: since there are no transactions yet, try "Eliminar permanentemente" — type the account name — confirm — verify account is deleted
    12. Resize browser to mobile width (less than 768px) — verify accounts display as cards instead of table

    Resume signal: Type "approved" if the full account lifecycle works, or describe any issues found.
  </action>
  <verify>
    <automated>cd /home/jacket/PROYECTOS/PERSONALES/Necronomics && npm run tauri dev -- --exit 2>&1 | head -5 || echo "Manual verification required — run npm run tauri dev"</automated>
  </verify>
  <done>User has verified the full account lifecycle: create all 3 types, edit with locked type, archive with toast, delete with typed confirmation and transaction guard, responsive layout.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all TypeScript compiles without errors
2. `npm run build` — Vite production build succeeds
3. Full lifecycle test: create all 3 account types, edit each, archive one, delete one
4. Credit-card form: credit_limit and billing_day required, validation fires on blur
5. Delete modal: typed confirmation required, delete blocked when transactions exist (backend returns error)
6. Success toasts appear after archive and delete actions
7. Responsive layout: table on desktop, cards on mobile
</verification>

<success_criteria>
- User can create cash, bank, and credit-card accounts with all required fields
- Credit-card accounts enforce credit_limit and billing_day in both create and edit
- Account type is locked (not editable) after creation
- Archive works with simple confirmation, returns to list with success toast
- Delete requires typed account name confirmation, is blocked when transactions exist
- Accounts list shows formatted balances with correct currency symbols
- Form validates on blur and shows submit-level error summary
- All UI text in Spanish
</success_criteria>

<output>
After completion, create `.planning/phases/01-accounts/01-03-SUMMARY.md`
</output>
